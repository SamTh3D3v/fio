<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Fio Manpage &mdash; fio 2.18-34-g8243 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.18-34-g8243',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="fio 2.18-34-g8243 documentation" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="fio-manpage">
<h1>Fio Manpage<a class="headerlink" href="#fio-manpage" title="Permalink to this headline">¶</a></h1>
<p>(rev. 2.18-34-g8243)</p>
<div class="section" id="overview-and-history">
<h2>Overview and history<a class="headerlink" href="#overview-and-history" title="Permalink to this headline">¶</a></h2>
<p>Fio was originally written to save me the hassle of writing special test case
programs when I wanted to test a specific workload, either for performance
reasons or to find/reproduce a bug. The process of writing such a test app can
be tiresome, especially if you have to do it often.  Hence I needed a tool that
would be able to simulate a given I/O workload without resorting to writing a
tailored test case again and again.</p>
<p>A test work load is difficult to define, though. There can be any number of
processes or threads involved, and they can each be using their own way of
generating I/O. You could have someone dirtying large amounts of memory in an
memory mapped file, or maybe several threads issuing reads using asynchronous
I/O. fio needed to be flexible enough to simulate both of these cases, and many
more.</p>
<p>Fio spawns a number of threads or processes doing a particular type of I/O
action as specified by the user. fio takes a number of global parameters, each
inherited by the thread unless otherwise parameters given to them overriding
that setting is given.  The typical use of fio is to write a job file matching
the I/O load one wants to simulate.</p>
</div>
<div class="section" id="source">
<h2>Source<a class="headerlink" href="#source" title="Permalink to this headline">¶</a></h2>
<p>Fio resides in a git repo, the canonical place is:</p>
<blockquote>
<div>git://git.kernel.dk/fio.git</div></blockquote>
<p>When inside a corporate firewall, git:// URL sometimes does not work.
If git:// does not work, use the http protocol instead:</p>
<blockquote>
<div><a class="reference external" href="http://git.kernel.dk/fio.git">http://git.kernel.dk/fio.git</a></div></blockquote>
<p>Snapshots are frequently generated and <code class="file docutils literal"><span class="pre">fio-git-*.tar.gz</span></code> include the git
meta data as well. Other tarballs are archives of official fio releases.
Snapshots can download from:</p>
<blockquote>
<div><a class="reference external" href="http://brick.kernel.dk/snaps/">http://brick.kernel.dk/snaps/</a></div></blockquote>
<p>There are also two official mirrors. Both of these are automatically synced with
the main repository, when changes are pushed. If the main repo is down for some
reason, either one of these is safe to use as a backup:</p>
<blockquote>
<div><p>git://git.kernel.org/pub/scm/linux/kernel/git/axboe/fio.git</p>
<p><a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/axboe/fio.git">https://git.kernel.org/pub/scm/linux/kernel/git/axboe/fio.git</a></p>
</div></blockquote>
<p>or</p>
<blockquote>
<div><p>git://github.com/axboe/fio.git</p>
<p><a class="reference external" href="https://github.com/axboe/fio.git">https://github.com/axboe/fio.git</a></p>
</div></blockquote>
</div>
<div class="section" id="mailing-list">
<h2>Mailing list<a class="headerlink" href="#mailing-list" title="Permalink to this headline">¶</a></h2>
<p>The fio project mailing list is meant for anything related to fio including
general discussion, bug reporting, questions, and development.</p>
<p>An automated mail detailing recent commits is automatically sent to the list at
most daily. The list address is <a class="reference external" href="mailto:fio&#37;&#52;&#48;vger&#46;kernel&#46;org">fio<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a>, subscribe by sending an
email to <a class="reference external" href="mailto:majordomo&#37;&#52;&#48;vger&#46;kernel&#46;org">majordomo<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a> with</p>
<blockquote>
<div>subscribe fio</div></blockquote>
<p>in the body of the email. Archives can be found here:</p>
<blockquote>
<div><a class="reference external" href="http://www.spinics.net/lists/fio/">http://www.spinics.net/lists/fio/</a></div></blockquote>
<p>and archives for the old list can be found here:</p>
<blockquote>
<div><a class="reference external" href="http://maillist.kernel.dk/fio-devel/">http://maillist.kernel.dk/fio-devel/</a></div></blockquote>
</div>
<div class="section" id="author">
<h2>Author<a class="headerlink" href="#author" title="Permalink to this headline">¶</a></h2>
<p>Fio was written by Jens Axboe &lt;<a class="reference external" href="mailto:axboe&#37;&#52;&#48;kernel&#46;dk">axboe<span>&#64;</span>kernel<span>&#46;</span>dk</a>&gt; to enable flexible testing of
the Linux I/O subsystem and schedulers. He got tired of writing specific test
applications to simulate a given workload, and found that the existing I/O
benchmark/test tools out there weren&#8217;t flexible enough to do what he wanted.</p>
<p>Jens Axboe &lt;<a class="reference external" href="mailto:axboe&#37;&#52;&#48;kernel&#46;dk">axboe<span>&#64;</span>kernel<span>&#46;</span>dk</a>&gt; 20060905</p>
</div>
<div class="section" id="binary-packages">
<h2>Binary packages<a class="headerlink" href="#binary-packages" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Debian:</dt>
<dd>Starting with Debian &#8220;Squeeze&#8221;, fio packages are part of the official
Debian repository. <a class="reference external" href="http://packages.debian.org/search?keywords=fio">http://packages.debian.org/search?keywords=fio</a> .</dd>
<dt>Ubuntu:</dt>
<dd>Starting with Ubuntu 10.04 LTS (aka &#8220;Lucid Lynx&#8221;), fio packages are part
of the Ubuntu &#8220;universe&#8221; repository.
<a class="reference external" href="http://packages.ubuntu.com/search?keywords=fio">http://packages.ubuntu.com/search?keywords=fio</a> .</dd>
<dt>Red Hat, Fedora, CentOS &amp; Co:</dt>
<dd>Starting with Fedora 9/Extra Packages for Enterprise Linux 4, fio
packages are part of the Fedora/EPEL repositories.
<a class="reference external" href="https://admin.fedoraproject.org/pkgdb/package/rpms/fio/">https://admin.fedoraproject.org/pkgdb/package/rpms/fio/</a> .</dd>
<dt>Mandriva:</dt>
<dd>Mandriva has integrated fio into their package repository, so installing
on that distro should be as easy as typing <code class="docutils literal"><span class="pre">urpmi</span> <span class="pre">fio</span></code>.</dd>
<dt>Solaris:</dt>
<dd>Packages for Solaris are available from OpenCSW. Install their pkgutil
tool (<a class="reference external" href="http://www.opencsw.org/get-it/pkgutil/">http://www.opencsw.org/get-it/pkgutil/</a>) and then install fio via
<code class="docutils literal"><span class="pre">pkgutil</span> <span class="pre">-i</span> <span class="pre">fio</span></code>.</dd>
<dt>Windows:</dt>
<dd>Rebecca Cran &lt;<a class="reference external" href="mailto:rebecca+fio&#37;&#52;&#48;bluestop&#46;org">rebecca+fio<span>&#64;</span>bluestop<span>&#46;</span>org</a>&gt; has fio packages for Windows at
<a class="reference external" href="http://www.bluestop.org/fio/">http://www.bluestop.org/fio/</a> .</dd>
<dt>BSDs:</dt>
<dd>Packages for BSDs may be available from their binary package repositories.
Look for a package &#8220;fio&#8221; using their binary package managers.</dd>
</dl>
</div>
<div class="section" id="building">
<h2>Building<a class="headerlink" href="#building" title="Permalink to this headline">¶</a></h2>
<p>Just type:</p>
<div class="highlight-python"><div class="highlight"><pre>$ ./configure
$ make
$ make install
</pre></div>
</div>
<p>Note that GNU make is required. On BSDs it&#8217;s available from devel/gmake within
ports directory; on Solaris it&#8217;s in the SUNWgmake package.  On platforms where
GNU make isn&#8217;t the default, type <code class="docutils literal"><span class="pre">gmake</span></code> instead of <code class="docutils literal"><span class="pre">make</span></code>.</p>
<p>Configure will print the enabled options. Note that on Linux based platforms,
the libaio development packages must be installed to use the libaio
engine. Depending on distro, it is usually called libaio-devel or libaio-dev.</p>
<p>For gfio, gtk 2.18 (or newer), associated glib threads, and cairo are required
to be installed.  gfio isn&#8217;t built automatically and can be enabled with a
<code class="docutils literal"><span class="pre">--enable-gfio</span></code> option to configure.</p>
<p>To build fio with a cross-compiler:</p>
<div class="highlight-python"><div class="highlight"><pre>$ make clean
$ make CROSS_COMPILE=/path/to/toolchain/prefix
</pre></div>
</div>
<p>Configure will attempt to determine the target platform automatically.</p>
<p>It&#8217;s possible to build fio for ESX as well, use the <code class="docutils literal"><span class="pre">--esx</span></code> switch to
configure.</p>
<div class="section" id="windows">
<h3>Windows<a class="headerlink" href="#windows" title="Permalink to this headline">¶</a></h3>
<p>On Windows, Cygwin (<a class="reference external" href="http://www.cygwin.com/">http://www.cygwin.com/</a>) is required in order to build
fio. To create an MSI installer package install WiX 3.8 from
<a class="reference external" href="http://wixtoolset.org">http://wixtoolset.org</a> and run <code class="file docutils literal"><span class="pre">dobuild.cmd</span></code> from the <code class="file docutils literal"><span class="pre">os/windows</span></code>
directory.</p>
<p>How to compile fio on 64-bit Windows:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Install Cygwin (<a class="reference external" href="http://www.cygwin.com/">http://www.cygwin.com/</a>). Install <strong>make</strong> and all
packages starting with <strong>mingw64-i686</strong> and <strong>mingw64-x86_64</strong>.</li>
<li>Open the Cygwin Terminal.</li>
<li>Go to the fio directory (source files).</li>
<li>Run <code class="docutils literal"><span class="pre">make</span> <span class="pre">clean</span> <span class="pre">&amp;&amp;</span> <span class="pre">make</span> <span class="pre">-j</span></code>.</li>
</ol>
</div></blockquote>
<p>To build fio on 32-bit Windows, run <code class="docutils literal"><span class="pre">./configure</span> <span class="pre">--build-32bit-win</span></code> before
<code class="docutils literal"><span class="pre">make</span></code>.</p>
<p>It&#8217;s recommended that once built or installed, fio be run in a Command Prompt or
other &#8216;native&#8217; console such as console2, since there are known to be display and
signal issues when running it under a Cygwin shell (see
<a class="reference external" href="http://code.google.com/p/mintty/issues/detail?id=56">http://code.google.com/p/mintty/issues/detail?id=56</a> for details).</p>
</div>
<div class="section" id="documentation">
<h3>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h3>
<p>Fio uses <a class="reference external" href="http://www.sphinx-doc.org">Sphinx</a> to generate documentation from the <a class="reference external" href="http://www.sphinx-doc.org/rest.html">reStructuredText</a> files.
To build HTML formatted documentation run <code class="docutils literal"><span class="pre">make</span> <span class="pre">-C</span> <span class="pre">doc</span> <span class="pre">html</span></code> and direct your
browser to <code class="file docutils literal"><span class="pre">./doc/output/html/index.html</span></code>.  To build manual page run
<code class="docutils literal"><span class="pre">make</span> <span class="pre">-C</span> <span class="pre">doc</span> <span class="pre">man</span></code> and then <code class="docutils literal"><span class="pre">man</span> <span class="pre">doc/output/man/fio.1</span></code>.  To see what other
output formats are supported run <code class="docutils literal"><span class="pre">make</span> <span class="pre">-C</span> <span class="pre">doc</span> <span class="pre">help</span></code>.</p>
</div>
</div>
<div class="section" id="platforms">
<h2>Platforms<a class="headerlink" href="#platforms" title="Permalink to this headline">¶</a></h2>
<p>Fio works on (at least) Linux, Solaris, AIX, HP-UX, OSX, NetBSD, OpenBSD,
Windows, FreeBSD, and DragonFly. Some features and/or options may only be
available on some of the platforms, typically because those features only apply
to that platform (like the solarisaio engine, or the splice engine on Linux).</p>
<p>Some features are not available on FreeBSD/Solaris even if they could be
implemented, I&#8217;d be happy to take patches for that. An example of that is disk
utility statistics and (I think) huge page support, support for that does exist
in FreeBSD/Solaris.</p>
<p>Fio uses pthread mutexes for signalling and locking and some platforms do not
support process shared pthread mutexes. As a result, on such platforms only
threads are supported. This could be fixed with sysv ipc locking or other
locking alternatives.</p>
<p>Other *BSD platforms are untested, but fio should work there almost out of the
box. Since I don&#8217;t do test runs or even compiles on those platforms, your
mileage may vary. Sending me patches for other platforms is greatly
appreciated. There&#8217;s a lot of value in having the same test/benchmark tool
available on all platforms.</p>
<p>Note that POSIX aio is not enabled by default on AIX. Messages like these:</p>
<div class="highlight-python"><div class="highlight"><pre>Symbol resolution failed for /usr/lib/libc.a(posix_aio.o) because:
    Symbol _posix_kaio_rdwr (number 2) is not exported from dependent module /unix.
</pre></div>
</div>
<p>indicate one needs to enable POSIX aio. Run the following commands as root:</p>
<div class="highlight-python"><div class="highlight"><pre># lsdev -C -l posix_aio0
    posix_aio0 Defined  Posix Asynchronous I/O
# cfgmgr -l posix_aio0
# lsdev -C -l posix_aio0
    posix_aio0 Available  Posix Asynchronous I/O
</pre></div>
</div>
<p>POSIX aio should work now. To make the change permanent:</p>
<div class="highlight-python"><div class="highlight"><pre># chdev -l posix_aio0 -P -a autoconfig=&#39;available&#39;
    posix_aio0 changed
</pre></div>
</div>
</div>
<div class="section" id="running-fio">
<h2>Running fio<a class="headerlink" href="#running-fio" title="Permalink to this headline">¶</a></h2>
<p>Running fio is normally the easiest part - you just give it the job file
(or job files) as parameters:</p>
<div class="highlight-python"><div class="highlight"><pre>$ fio [options] [jobfile] ...
</pre></div>
</div>
<p>and it will start doing what the <em>jobfile</em> tells it to do. You can give more
than one job file on the command line, fio will serialize the running of those
files. Internally that is the same as using the <a class="reference internal" href="#cmdoption-arg-stonewall"><code class="xref std std-option docutils literal"><span class="pre">stonewall</span></code></a> parameter
described in the parameter section.</p>
<p>If the job file contains only one job, you may as well just give the parameters
on the command line. The command line parameters are identical to the job
parameters, with a few extra that control global parameters.  For example, for
the job file parameter <a class="reference internal" href="#cmdoption-arg-iodepth"><code class="xref std std-option docutils literal"><span class="pre">iodepth=2</span></code></a>, the mirror command line
option would be <a class="reference internal" href="#cmdoption-arg-iodepth"><code class="xref std std-option docutils literal"><span class="pre">--iodepth</span> <span class="pre">2</span></code></a> or <a class="reference internal" href="#cmdoption-arg-iodepth"><code class="xref std std-option docutils literal"><span class="pre">--iodepth=2</span></code></a>. You can also use the command line for giving more than one job
entry. For each <a class="reference internal" href="#cmdoption-arg-name"><code class="xref std std-option docutils literal"><span class="pre">--name</span></code></a> option that fio sees, it will start a
new job with that name.  Command line entries following a
<a class="reference internal" href="#cmdoption-arg-name"><code class="xref std std-option docutils literal"><span class="pre">--name</span></code></a> entry will apply to that job, until there are no more
entries or a new <a class="reference internal" href="#cmdoption-arg-name"><code class="xref std std-option docutils literal"><span class="pre">--name</span></code></a> entry is seen. This is similar to the
job file options, where each option applies to the current job until a new []
job entry is seen.</p>
<p>fio does not need to run as root, except if the files or devices specified in
the job section requires that. Some other options may also be restricted, such
as memory locking, I/O scheduler switching, and decreasing the nice value.</p>
<p>If <em>jobfile</em> is specified as <code class="docutils literal"><span class="pre">-</span></code>, the job file will be read from standard
input.</p>
</div>
<div class="section" id="how-fio-works">
<h2>How fio works<a class="headerlink" href="#how-fio-works" title="Permalink to this headline">¶</a></h2>
<p>The first step in getting fio to simulate a desired I/O workload, is writing a
job file describing that specific setup. A job file may contain any number of
threads and/or files &#8211; the typical contents of the job file is a <em>global</em>
section defining shared parameters, and one or more job sections describing the
jobs involved. When run, fio parses this file and sets everything up as
described. If we break down a job from top to bottom, it contains the following
basic parameters:</p>
<p><a class="reference internal" href="#i-o-type">I/O type</a></p>
<blockquote>
<div>Defines the I/O pattern issued to the file(s).  We may only be reading
sequentially from this file(s), or we may be writing randomly. Or even
mixing reads and writes, sequentially or randomly.
Should we be doing buffered I/O, or direct/raw I/O?</div></blockquote>
<p><a class="reference internal" href="#block-size">Block size</a></p>
<blockquote>
<div>In how large chunks are we issuing I/O? This may be a single value,
or it may describe a range of block sizes.</div></blockquote>
<p><a class="reference internal" href="#i-o-size">I/O size</a></p>
<blockquote>
<div>How much data are we going to be reading/writing.</div></blockquote>
<p><a class="reference internal" href="#i-o-engine">I/O engine</a></p>
<blockquote>
<div>How do we issue I/O? We could be memory mapping the file, we could be
using regular read/write, we could be using splice, async I/O, or even
SG (SCSI generic sg).</div></blockquote>
<p><a class="reference internal" href="#i-o-depth">I/O depth</a></p>
<blockquote>
<div>If the I/O engine is async, how large a queuing depth do we want to
maintain?</div></blockquote>
<p><a class="reference internal" href="#target-file-device">Target file/device</a></p>
<blockquote>
<div>How many files are we spreading the workload over.</div></blockquote>
<p><a class="reference internal" href="#threads-processes-and-job-synchronization">Threads, processes and job synchronization</a></p>
<blockquote>
<div>How many threads or processes should we spread this workload over.</div></blockquote>
<p>The above are the basic parameters defined for a workload, in addition there&#8217;s a
multitude of parameters that modify other aspects of how this job behaves.</p>
</div>
<div class="section" id="command-line-options">
<h2>Command line options<a class="headerlink" href="#command-line-options" title="Permalink to this headline">¶</a></h2>
<dl class="option">
<dt id="cmdoption--debug">
<code class="descname">--debug</code><code class="descclassname">=type</code><a class="headerlink" href="#cmdoption--debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable verbose tracing of various fio actions.  May be <code class="docutils literal"><span class="pre">all</span></code> for all types
or individual types separated by a comma (e.g. <code class="docutils literal"><span class="pre">--debug=file,mem</span></code> will
enable file and memory debugging).  Currently, additional logging is
available for:</p>
<dl class="docutils">
<dt><em>process</em></dt>
<dd>Dump info related to processes.</dd>
<dt><em>file</em></dt>
<dd>Dump info related to file actions.</dd>
<dt><em>io</em></dt>
<dd>Dump info related to I/O queuing.</dd>
<dt><em>mem</em></dt>
<dd>Dump info related to memory allocations.</dd>
<dt><em>blktrace</em></dt>
<dd>Dump info related to blktrace setup.</dd>
<dt><em>verify</em></dt>
<dd>Dump info related to I/O verification.</dd>
<dt><em>all</em></dt>
<dd>Enable all debug options.</dd>
<dt><em>random</em></dt>
<dd>Dump info related to random offset generation.</dd>
<dt><em>parse</em></dt>
<dd>Dump info related to option matching and parsing.</dd>
<dt><em>diskutil</em></dt>
<dd>Dump info related to disk utilization updates.</dd>
<dt><em>job:x</em></dt>
<dd>Dump info only related to job number x.</dd>
<dt><em>mutex</em></dt>
<dd>Dump info only related to mutex up/down ops.</dd>
<dt><em>profile</em></dt>
<dd>Dump info related to profile extensions.</dd>
<dt><em>time</em></dt>
<dd>Dump info related to internal time keeping.</dd>
<dt><em>net</em></dt>
<dd>Dump info related to networking connections.</dd>
<dt><em>rate</em></dt>
<dd>Dump info related to I/O rate switching.</dd>
<dt><em>compress</em></dt>
<dd>Dump info related to log compress/decompress.</dd>
<dt><em>?</em> or <em>help</em></dt>
<dd>Show available debug options.</dd>
</dl>
</dd></dl>

<dl class="option">
<dt id="cmdoption--parse-only">
<code class="descname">--parse-only</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption--parse-only" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse options only, don&#8217;t start any I/O.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--output">
<code class="descname">--output</code><code class="descclassname">=filename</code><a class="headerlink" href="#cmdoption--output" title="Permalink to this definition">¶</a></dt>
<dd><p>Write output to file <cite>filename</cite>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--bandwidth-log">
<code class="descname">--bandwidth-log</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption--bandwidth-log" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate aggregate bandwidth logs.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--minimal">
<code class="descname">--minimal</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption--minimal" title="Permalink to this definition">¶</a></dt>
<dd><p>Print statistics in a terse, semicolon-delimited format.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--append-terse">
<code class="descname">--append-terse</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption--append-terse" title="Permalink to this definition">¶</a></dt>
<dd><p>Print statistics in selected mode AND terse, semicolon-delimited format.
<strong>deprecated</strong>, use <a class="reference internal" href="#cmdoption--output-format"><code class="xref std std-option docutils literal"><span class="pre">--output-format</span></code></a> instead to select multiple
formats.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--output-format">
<code class="descname">--output-format</code><code class="descclassname">=type</code><a class="headerlink" href="#cmdoption--output-format" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the reporting format to <cite>normal</cite>, <cite>terse</cite>, <cite>json</cite>, or <cite>json+</cite>.  Multiple
formats can be selected, separate by a comma.  <cite>terse</cite> is a CSV based
format.  <cite>json+</cite> is like <cite>json</cite>, except it adds a full dump of the latency
buckets.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--terse-version">
<code class="descname">--terse-version</code><code class="descclassname">=type</code><a class="headerlink" href="#cmdoption--terse-version" title="Permalink to this definition">¶</a></dt>
<dd><p>Set terse version output format (default 3, or 2 or 4).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--version">
<code class="descname">--version</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption--version" title="Permalink to this definition">¶</a></dt>
<dd><p>Print version info and exit.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--help">
<code class="descname">--help</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption--help" title="Permalink to this definition">¶</a></dt>
<dd><p>Print this page.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--cpuclock-test">
<code class="descname">--cpuclock-test</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption--cpuclock-test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform test and validation of internal CPU clock.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--crctest">
<code class="descname">--crctest</code><code class="descclassname">=test</code><a class="headerlink" href="#cmdoption--crctest" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the speed of the builtin checksumming functions. If no argument is
given, all of them are tested. Or a comma separated list can be passed, in
which case the given ones are tested.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--cmdhelp">
<code class="descname">--cmdhelp</code><code class="descclassname">=command</code><a class="headerlink" href="#cmdoption--cmdhelp" title="Permalink to this definition">¶</a></dt>
<dd><p>Print help information for <cite>command</cite>. May be <code class="docutils literal"><span class="pre">all</span></code> for all commands.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--enghelp">
<code class="descname">--enghelp</code><code class="descclassname">=[ioengine[,command]]</code><a class="headerlink" href="#cmdoption--enghelp" title="Permalink to this definition">¶</a></dt>
<dd><p>List all commands defined by <a class="reference internal" href="#cmdoption-arg-ioengine"><code class="xref std std-option docutils literal"><span class="pre">ioengine</span></code></a>, or print help for <cite>command</cite>
defined by <a class="reference internal" href="#cmdoption-arg-ioengine"><code class="xref std std-option docutils literal"><span class="pre">ioengine</span></code></a>.  If no <a class="reference internal" href="#cmdoption-arg-ioengine"><code class="xref std std-option docutils literal"><span class="pre">ioengine</span></code></a> is given, list all
available ioengines.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--showcmd">
<code class="descname">--showcmd</code><code class="descclassname">=jobfile</code><a class="headerlink" href="#cmdoption--showcmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a job file into command line options.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--readonly">
<code class="descname">--readonly</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption--readonly" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn on safety read-only checks, preventing writes.  The <code class="docutils literal"><span class="pre">--readonly</span></code>
option is an extra safety guard to prevent users from accidentally starting
a write workload when that is not desired.  Fio will only write if
<cite>rw=write/randwrite/rw/randrw</cite> is given.  This extra safety net can be used
as an extra precaution as <code class="docutils literal"><span class="pre">--readonly</span></code> will also enable a write check in
the I/O engine core to prevent writes due to unknown user space bug(s).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--eta">
<code class="descname">--eta</code><code class="descclassname">=when</code><a class="headerlink" href="#cmdoption--eta" title="Permalink to this definition">¶</a></dt>
<dd><p>When real-time ETA estimate should be printed.  May be <cite>always</cite>, <cite>never</cite> or
<cite>auto</cite>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--eta-newline">
<code class="descname">--eta-newline</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption--eta-newline" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a new line for every <cite>time</cite> period passed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--status-interval">
<code class="descname">--status-interval</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption--status-interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Force full status dump every <cite>time</cite> period passed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--section">
<code class="descname">--section</code><code class="descclassname">=name</code><a class="headerlink" href="#cmdoption--section" title="Permalink to this definition">¶</a></dt>
<dd><p>Only run specified section in job file.  Multiple sections can be specified.
The <code class="docutils literal"><span class="pre">--section</span></code> option allows one to combine related jobs into one file.
E.g. one job file could define light, moderate, and heavy sections. Tell
fio to run only the &#8220;heavy&#8221; section by giving <code class="docutils literal"><span class="pre">--section=heavy</span></code>
command line option.  One can also specify the &#8220;write&#8221; operations in one
section and &#8220;verify&#8221; operation in another section.  The <code class="docutils literal"><span class="pre">--section</span></code> option
only applies to job sections.  The reserved <em>global</em> section is always
parsed and used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--alloc-size">
<code class="descname">--alloc-size</code><code class="descclassname">=kb</code><a class="headerlink" href="#cmdoption--alloc-size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the internal smalloc pool to this size in kb (def 1024).  The
<code class="docutils literal"><span class="pre">--alloc-size</span></code> switch allows one to use a larger pool size for smalloc.
If running large jobs with randommap enabled, fio can run out of memory.
Smalloc is an internal allocator for shared structures from a fixed size
memory pool. The pool size defaults to 16M and can grow to 8 pools.</p>
<p>NOTE: While running <code class="file docutils literal"><span class="pre">.fio_smalloc.*</span></code> backing store files are visible
in <code class="file docutils literal"><span class="pre">/tmp</span></code>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--warnings-fatal">
<code class="descname">--warnings-fatal</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption--warnings-fatal" title="Permalink to this definition">¶</a></dt>
<dd><p>All fio parser warnings are fatal, causing fio to exit with an
error.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--max-jobs">
<code class="descname">--max-jobs</code><code class="descclassname">=nr</code><a class="headerlink" href="#cmdoption--max-jobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum number of threads/processes to support.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--server">
<code class="descname">--server</code><code class="descclassname">=args</code><a class="headerlink" href="#cmdoption--server" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a backend server, with <cite>args</cite> specifying what to listen to.
See <a class="reference internal" href="#client-server">Client/Server</a> section.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--daemonize">
<code class="descname">--daemonize</code><code class="descclassname">=pidfile</code><a class="headerlink" href="#cmdoption--daemonize" title="Permalink to this definition">¶</a></dt>
<dd><p>Background a fio server, writing the pid to the given <cite>pidfile</cite> file.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--client">
<code class="descname">--client</code><code class="descclassname">=hostname</code><a class="headerlink" href="#cmdoption--client" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of running the jobs locally, send and run them on the given host or
set of hosts.  See <a class="reference internal" href="#client-server">Client/Server</a> section.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--remote-config">
<code class="descname">--remote-config</code><code class="descclassname">=file</code><a class="headerlink" href="#cmdoption--remote-config" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell fio server to load this local file.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--idle-prof">
<code class="descname">--idle-prof</code><code class="descclassname">=option</code><a class="headerlink" href="#cmdoption--idle-prof" title="Permalink to this definition">¶</a></dt>
<dd><p>Report cpu idleness on a system or percpu basis
<code class="docutils literal"><span class="pre">--idle-prof=system,percpu</span></code> or
run unit work calibration only <code class="docutils literal"><span class="pre">--idle-prof=calibrate</span></code>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--inflate-log">
<code class="descname">--inflate-log</code><code class="descclassname">=log</code><a class="headerlink" href="#cmdoption--inflate-log" title="Permalink to this definition">¶</a></dt>
<dd><p>Inflate and output compressed log.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--trigger-file">
<code class="descname">--trigger-file</code><code class="descclassname">=file</code><a class="headerlink" href="#cmdoption--trigger-file" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute trigger cmd when file exists.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--trigger-timeout">
<code class="descname">--trigger-timeout</code><code class="descclassname">=t</code><a class="headerlink" href="#cmdoption--trigger-timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute trigger at this time.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--trigger">
<code class="descname">--trigger</code><code class="descclassname">=cmd</code><a class="headerlink" href="#cmdoption--trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this command as local trigger.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--trigger-remote">
<code class="descname">--trigger-remote</code><code class="descclassname">=cmd</code><a class="headerlink" href="#cmdoption--trigger-remote" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this command as remote trigger.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption--aux-path">
<code class="descname">--aux-path</code><code class="descclassname">=path</code><a class="headerlink" href="#cmdoption--aux-path" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this path for fio state generated files.</p>
</dd></dl>

<p>Any parameters following the options will be assumed to be job files, unless
they match a job file parameter. Multiple job files can be listed and each job
file will be regarded as a separate group. Fio will <a class="reference internal" href="#cmdoption-arg-stonewall"><code class="xref std std-option docutils literal"><span class="pre">stonewall</span></code></a>
execution between each group.</p>
</div>
<div class="section" id="job-file-format">
<h2>Job file format<a class="headerlink" href="#job-file-format" title="Permalink to this headline">¶</a></h2>
<p>As previously described, fio accepts one or more job files describing what it is
supposed to do. The job file format is the classic ini file, where the names
enclosed in [] brackets define the job name. You are free to use any ASCII name
you want, except <em>global</em> which has special meaning.  Following the job name is
a sequence of zero or more parameters, one per line, that define the behavior of
the job. If the first character in a line is a &#8216;;&#8217; or a &#8216;#&#8217;, the entire line is
discarded as a comment.</p>
<p>A <em>global</em> section sets defaults for the jobs described in that file. A job may
override a <em>global</em> section parameter, and a job file may even have several
<em>global</em> sections if so desired. A job is only affected by a <em>global</em> section
residing above it.</p>
<p>The <a class="reference internal" href="#cmdoption--cmdhelp"><code class="xref std std-option docutils literal"><span class="pre">--cmdhelp</span></code></a> option also lists all options. If used with an <cite>option</cite>
argument, <a class="reference internal" href="#cmdoption--cmdhelp"><code class="xref std std-option docutils literal"><span class="pre">--cmdhelp</span></code></a> will detail the given <cite>option</cite>.</p>
<p>See the <cite>examples/</cite> directory for inspiration on how to write job files.  Note
the copyright and license requirements currently apply to <cite>examples/</cite> files.</p>
<p>So let&#8217;s look at a really simple job file that defines two processes, each
randomly reading from a 128MiB file:</p>
<div class="highlight-ini"><div class="highlight"><pre><span class="c1">; -- start job file --</span>
<span class="k">[global]</span>
<span class="na">rw</span><span class="o">=</span><span class="s">randread</span>
<span class="na">size</span><span class="o">=</span><span class="s">128m</span>

<span class="k">[job1]</span>

<span class="k">[job2]</span>

<span class="c1">; -- end job file --</span>
</pre></div>
</div>
<p>As you can see, the job file sections themselves are empty as all the described
parameters are shared. As no <a class="reference internal" href="#cmdoption-arg-filename"><code class="xref std std-option docutils literal"><span class="pre">filename</span></code></a> option is given, fio makes up a
<cite>filename</cite> for each of the jobs as it sees fit. On the command line, this job
would look as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>$ fio --name=global --rw=randread --size=128m --name=job1 --name=job2
</pre></div>
</div>
<p>Let&#8217;s look at an example that has a number of processes writing randomly to
files:</p>
<div class="highlight-ini"><div class="highlight"><pre><span class="c1">; -- start job file --</span>
<span class="k">[random-writers]</span>
<span class="na">ioengine</span><span class="o">=</span><span class="s">libaio</span>
<span class="na">iodepth</span><span class="o">=</span><span class="s">4</span>
<span class="na">rw</span><span class="o">=</span><span class="s">randwrite</span>
<span class="na">bs</span><span class="o">=</span><span class="s">32k</span>
<span class="na">direct</span><span class="o">=</span><span class="s">0</span>
<span class="na">size</span><span class="o">=</span><span class="s">64m</span>
<span class="na">numjobs</span><span class="o">=</span><span class="s">4</span>
<span class="c1">; -- end job file --</span>
</pre></div>
</div>
<p>Here we have no <em>global</em> section, as we only have one job defined anyway.  We
want to use async I/O here, with a depth of 4 for each file. We also increased
the buffer size used to 32KiB and define numjobs to 4 to fork 4 identical
jobs. The result is 4 processes each randomly writing to their own 64MiB
file. Instead of using the above job file, you could have given the parameters
on the command line. For this case, you would specify:</p>
<div class="highlight-python"><div class="highlight"><pre>$ fio --name=random-writers --ioengine=libaio --iodepth=4 --rw=randwrite --bs=32k --direct=0 --size=64m --numjobs=4
</pre></div>
</div>
<p>When fio is utilized as a basis of any reasonably large test suite, it might be
desirable to share a set of standardized settings across multiple job files.
Instead of copy/pasting such settings, any section may pull in an external
<code class="file docutils literal"><span class="pre">filename.fio</span></code> file with <em>include filename</em> directive, as in the following
example:</p>
<div class="highlight-python"><div class="highlight"><pre>; -- start job file including.fio --
[global]
filename=/tmp/test
filesize=1m
include glob-include.fio

[test]
rw=randread
bs=4k
time_based=1
runtime=10
include test-include.fio
; -- end job file including.fio --
</pre></div>
</div>
<div class="highlight-ini"><div class="highlight"><pre><span class="c1">; -- start job file glob-include.fio --</span>
<span class="na">thread</span><span class="o">=</span><span class="s">1</span>
<span class="na">group_reporting</span><span class="o">=</span><span class="s">1</span>
<span class="c1">; -- end job file glob-include.fio --</span>
</pre></div>
</div>
<div class="highlight-ini"><div class="highlight"><pre><span class="c1">; -- start job file test-include.fio --</span>
<span class="na">ioengine</span><span class="o">=</span><span class="s">libaio</span>
<span class="na">iodepth</span><span class="o">=</span><span class="s">4</span>
<span class="c1">; -- end job file test-include.fio --</span>
</pre></div>
</div>
<p>Settings pulled into a section apply to that section only (except <em>global</em>
section). Include directives may be nested in that any included file may contain
further include directive(s). Include files may not contain [] sections.</p>
<div class="section" id="environment-variables">
<h3>Environment variables<a class="headerlink" href="#environment-variables" title="Permalink to this headline">¶</a></h3>
<p>Fio also supports environment variable expansion in job files. Any sub-string of
the form <code class="docutils literal"><span class="pre">${VARNAME}</span></code> as part of an option value (in other words, on the right
of the &#8216;=&#8217;), will be expanded to the value of the environment variable called
<cite>VARNAME</cite>.  If no such environment variable is defined, or <cite>VARNAME</cite> is the
empty string, the empty string will be substituted.</p>
<p>As an example, let&#8217;s look at a sample fio invocation and job file:</p>
<div class="highlight-python"><div class="highlight"><pre>$ SIZE=64m NUMJOBS=4 fio jobfile.fio
</pre></div>
</div>
<div class="highlight-ini"><div class="highlight"><pre><span class="c1">; -- start job file --</span>
<span class="k">[random-writers]</span>
<span class="na">rw</span><span class="o">=</span><span class="s">randwrite</span>
<span class="na">size</span><span class="o">=</span><span class="s">${SIZE}</span>
<span class="na">numjobs</span><span class="o">=</span><span class="s">${NUMJOBS}</span>
<span class="c1">; -- end job file --</span>
</pre></div>
</div>
<p>This will expand to the following equivalent job file at runtime:</p>
<div class="highlight-ini"><div class="highlight"><pre><span class="c1">; -- start job file --</span>
<span class="k">[random-writers]</span>
<span class="na">rw</span><span class="o">=</span><span class="s">randwrite</span>
<span class="na">size</span><span class="o">=</span><span class="s">64m</span>
<span class="na">numjobs</span><span class="o">=</span><span class="s">4</span>
<span class="c1">; -- end job file --</span>
</pre></div>
</div>
<p>Fio ships with a few example job files, you can also look there for inspiration.</p>
</div>
<div class="section" id="reserved-keywords">
<h3>Reserved keywords<a class="headerlink" href="#reserved-keywords" title="Permalink to this headline">¶</a></h3>
<p>Additionally, fio has a set of reserved keywords that will be replaced
internally with the appropriate value. Those keywords are:</p>
<p><strong>$pagesize</strong></p>
<blockquote>
<div>The architecture page size of the running system.</div></blockquote>
<p><strong>$mb_memory</strong></p>
<blockquote>
<div>Megabytes of total memory in the system.</div></blockquote>
<p><strong>$ncpus</strong></p>
<blockquote>
<div>Number of online available CPUs.</div></blockquote>
<p>These can be used on the command line or in the job file, and will be
automatically substituted with the current system values when the job is
run. Simple math is also supported on these keywords, so you can perform actions
like:</p>
<div class="highlight-python"><div class="highlight"><pre>size=8*$mb_memory
</pre></div>
</div>
<p>and get that properly expanded to 8 times the size of memory in the machine.</p>
</div>
</div>
<div class="section" id="job-file-parameters">
<h2>Job file parameters<a class="headerlink" href="#job-file-parameters" title="Permalink to this headline">¶</a></h2>
<p>This section describes in details each parameter associated with a job.  Some
parameters take an option of a given type, such as an integer or a
string. Anywhere a numeric value is required, an arithmetic expression may be
used, provided it is surrounded by parentheses. Supported operators are:</p>
<blockquote>
<div><ul class="simple">
<li>addition (+)</li>
<li>subtraction (-)</li>
<li>multiplication (*)</li>
<li>division (/)</li>
<li>modulus (%)</li>
<li>exponentiation (^)</li>
</ul>
</div></blockquote>
<p>For time values in expressions, units are microseconds by default. This is
different than for time values not in expressions (not enclosed in
parentheses). The following types are used:</p>
<div class="section" id="parameter-types">
<h3>Parameter types<a class="headerlink" href="#parameter-types" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><strong>str</strong></dt>
<dd>String. This is a sequence of alpha characters.</dd>
<dt><strong>time</strong></dt>
<dd>Integer with possible time suffix. In seconds unless otherwise
specified, use e.g. 10m for 10 minutes. Accepts s/m/h for seconds, minutes,
and hours, and accepts &#8216;ms&#8217; (or &#8216;msec&#8217;) for milliseconds, and &#8216;us&#8217; (or
&#8216;usec&#8217;) for microseconds.</dd>
</dl>
<dl class="docutils" id="int">
<dt><strong>int</strong></dt>
<dd><p class="first">Integer. A whole number value, which may contain an integer prefix
and an integer suffix:</p>
<p>[<em>integer prefix</em>] <strong>number</strong> [<em>integer suffix</em>]</p>
<p>The optional <em>integer prefix</em> specifies the number&#8217;s base. The default
is decimal. <em>0x</em> specifies hexadecimal.</p>
<p>The optional <em>integer suffix</em> specifies the number&#8217;s units, and includes an
optional unit prefix and an optional unit.  For quantities of data, the
default unit is bytes. For quantities of time, the default unit is seconds.</p>
<p>With <a class="reference internal" href="#cmdoption-arg-kb_base"><code class="xref std std-option docutils literal"><span class="pre">kb_base</span></code></a> =1000, fio follows international standards for unit
prefixes.  To specify power-of-10 decimal values defined in the
International System of Units (SI):</p>
<blockquote>
<div><ul class="simple">
<li><em>Ki</em> &#8211; means kilo (K) or 1000</li>
<li><em>Mi</em> &#8211; means mega (M) or 1000**2</li>
<li><em>Gi</em> &#8211; means giga (G) or 1000**3</li>
<li><em>Ti</em> &#8211; means tera (T) or 1000**4</li>
<li><em>Pi</em> &#8211; means peta (P) or 1000**5</li>
</ul>
</div></blockquote>
<p>To specify power-of-2 binary values defined in IEC 80000-13:</p>
<blockquote>
<div><ul class="simple">
<li><em>k</em> &#8211; means kibi (Ki) or 1024</li>
<li><em>M</em> &#8211; means mebi (Mi) or 1024**2</li>
<li><em>G</em> &#8211; means gibi (Gi) or 1024**3</li>
<li><em>T</em> &#8211; means tebi (Ti) or 1024**4</li>
<li><em>P</em> &#8211; means pebi (Pi) or 1024**5</li>
</ul>
</div></blockquote>
<p>With <a class="reference internal" href="#cmdoption-arg-kb_base"><code class="xref std std-option docutils literal"><span class="pre">kb_base</span></code></a> =1024 (the default), the unit prefixes are opposite
from those specified in the SI and IEC 80000-13 standards to provide
compatibility with old scripts.  For example, 4k means 4096.</p>
<p>For quantities of data, an optional unit of &#8216;B&#8217; may be included
(e.g.,  &#8216;kB&#8217; is the same as &#8216;k&#8217;).</p>
<p>The <em>integer suffix</em> is not case sensitive (e.g., m/mi mean mebi/mega,
not milli). &#8216;b&#8217; and &#8216;B&#8217; both mean byte, not bit.</p>
<p>Examples with <a class="reference internal" href="#cmdoption-arg-kb_base"><code class="xref std std-option docutils literal"><span class="pre">kb_base</span></code></a> =1000:</p>
<blockquote>
<div><ul class="simple">
<li><em>4 KiB</em>: 4096, 4096b, 4096B, 4ki, 4kib, 4kiB, 4Ki, 4KiB</li>
<li><em>1 MiB</em>: 1048576, 1mi, 1024ki</li>
<li><em>1 MB</em>: 1000000, 1m, 1000k</li>
<li><em>1 TiB</em>: 1099511627776, 1ti, 1024gi, 1048576mi</li>
<li><em>1 TB</em>: 1000000000, 1t, 1000m, 1000000k</li>
</ul>
</div></blockquote>
<p>Examples with <a class="reference internal" href="#cmdoption-arg-kb_base"><code class="xref std std-option docutils literal"><span class="pre">kb_base</span></code></a> =1024 (default):</p>
<blockquote>
<div><ul class="simple">
<li><em>4 KiB</em>: 4096, 4096b, 4096B, 4k, 4kb, 4kB, 4K, 4KB</li>
<li><em>1 MiB</em>: 1048576, 1m, 1024k</li>
<li><em>1 MB</em>: 1000000, 1mi, 1000ki</li>
<li><em>1 TiB</em>: 1099511627776, 1t, 1024g, 1048576m</li>
<li><em>1 TB</em>: 1000000000, 1ti, 1000mi, 1000000ki</li>
</ul>
</div></blockquote>
<p>To specify times (units are not case sensitive):</p>
<blockquote>
<div><ul class="simple">
<li><em>D</em> &#8211; means days</li>
<li><em>H</em> &#8211; means hours</li>
<li><em>M</em> &#8211; mean minutes</li>
<li><em>s</em> &#8211; or sec means seconds (default)</li>
<li><em>ms</em> &#8211; or <em>msec</em> means milliseconds</li>
<li><em>us</em> &#8211; or <em>usec</em> means microseconds</li>
</ul>
</div></blockquote>
<p class="last">If the option accepts an upper and lower range, use a colon &#8216;:&#8217; or
minus &#8216;-&#8216; to separate such values. See <a class="reference internal" href="#irange"><span>irange</span></a>.</p>
</dd>
</dl>
<dl class="docutils" id="bool">
<dt><strong>bool</strong></dt>
<dd>Boolean. Usually parsed as an integer, however only defined for
true and false (1 and 0).</dd>
</dl>
<dl class="docutils" id="irange">
<dt><strong>irange</strong></dt>
<dd>Integer range with suffix. Allows value range to be given, such as
1024-4096. A colon may also be used as the separator, e.g. 1k:4k. If the
option allows two sets of ranges, they can be specified with a &#8216;,&#8217; or &#8216;/&#8217;
delimiter: 1k-4k/8k-32k. Also see <a class="reference internal" href="#int"><span>int</span></a>.</dd>
<dt><strong>float_list</strong></dt>
<dd>A list of floating point numbers, separated by a &#8216;:&#8217; character.</dd>
</dl>
</div>
<div class="section" id="units">
<h3>Units<a class="headerlink" href="#units" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-kb_base">
<code class="descname">kb_base</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-kb_base" title="Permalink to this definition">¶</a></dt>
<dd><p>Select the interpretation of unit prefixes in input parameters.</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>1000</strong></dt>
<dd><p class="first">Inputs comply with IEC 80000-13 and the International
System of Units (SI). Use:</p>
<blockquote class="last">
<div><ul class="simple">
<li>power-of-2 values with IEC prefixes (e.g., KiB)</li>
<li>power-of-10 values with SI prefixes (e.g., kB)</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>1024</strong></dt>
<dd><p class="first">Compatibility mode (default).  To avoid breaking old scripts:</p>
<blockquote class="last">
<div><ul class="simple">
<li>power-of-2 values with SI prefixes</li>
<li>power-of-10 values with IEC prefixes</li>
</ul>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>See <a class="reference internal" href="#cmdoption-arg-bs"><code class="xref std std-option docutils literal"><span class="pre">bs</span></code></a> for more details on input parameters.</p>
<p>Outputs always use correct prefixes.  Most outputs include both
side-by-side, like:</p>
<div class="highlight-python"><div class="highlight"><pre>bw=2383.3kB/s (2327.4KiB/s)
</pre></div>
</div>
<p>If only one value is reported, then kb_base selects the one to use:</p>
<blockquote>
<div><p><strong>1000</strong> &#8211; SI prefixes</p>
<p><strong>1024</strong> &#8211; IEC prefixes</p>
</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-unit_base">
<code class="descname">unit_base</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-unit_base" title="Permalink to this definition">¶</a></dt>
<dd><p>Base unit for reporting.  Allowed values are:</p>
<dl class="docutils">
<dt><strong>0</strong></dt>
<dd>Use auto-detection (default).</dd>
<dt><strong>8</strong></dt>
<dd>Byte based.</dd>
<dt><strong>1</strong></dt>
<dd>Bit based.</dd>
</dl>
</dd></dl>

<p>With the above in mind, here follows the complete list of fio job parameters.</p>
</div>
<div class="section" id="job-description">
<h3>Job description<a class="headerlink" href="#job-description" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-name">
<code class="descname">name</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-name" title="Permalink to this definition">¶</a></dt>
<dd><p>ASCII name of the job. This may be used to override the name printed by fio
for this job. Otherwise the job name is used. On the command line this
parameter has the special purpose of also signaling the start of a new job.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-description">
<code class="descname">description</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-description" title="Permalink to this definition">¶</a></dt>
<dd><p>Text description of the job. Doesn&#8217;t do anything except dump this text
description when this job is run. It&#8217;s not parsed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-loops">
<code class="descname">loops</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the specified number of iterations of this job. Used to repeat the same
workload a given number of times. Defaults to 1.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-numjobs">
<code class="descname">numjobs</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-numjobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the specified number of clones of this job. Each clone of job
is spawned as an independent thread or process. May be used to setup a
larger number of threads/processes doing the same thing. Each thread is
reported separately; to see statistics for all clones as a whole, use
<a class="reference internal" href="#cmdoption-arg-group_reporting"><code class="xref std std-option docutils literal"><span class="pre">group_reporting</span></code></a> in conjunction with <a class="reference internal" href="#cmdoption-arg-new_group"><code class="xref std std-option docutils literal"><span class="pre">new_group</span></code></a>.
See <a class="reference internal" href="#cmdoption--max-jobs"><code class="xref std std-option docutils literal"><span class="pre">--max-jobs</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="time-related-parameters">
<h3>Time related parameters<a class="headerlink" href="#time-related-parameters" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-runtime">
<code class="descname">runtime</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell fio to terminate processing after the specified period of time.  It
can be quite hard to determine for how long a specified job will run, so
this parameter is handy to cap the total runtime to a given time.  When
the unit is omitted, the value is given in seconds.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-time_based">
<code class="descname">time_based</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-time_based" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will run for the duration of the <a class="reference internal" href="#cmdoption-arg-runtime"><code class="xref std std-option docutils literal"><span class="pre">runtime</span></code></a> specified
even if the file(s) are completely read or written. It will simply loop over
the same workload as many times as the <a class="reference internal" href="#cmdoption-arg-runtime"><code class="xref std std-option docutils literal"><span class="pre">runtime</span></code></a> allows.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-startdelay">
<code class="descname">startdelay</code><code class="descclassname">=irange(time)</code><a class="headerlink" href="#cmdoption-arg-startdelay" title="Permalink to this definition">¶</a></dt>
<dd><p>Delay start of job for the specified number of seconds. Supports all time
suffixes to allow specification of hours, minutes, seconds and milliseconds
&#8211; seconds are the default if a unit is omitted.  Can be given as a range
which causes each thread to choose randomly out of the range.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ramp_time">
<code class="descname">ramp_time</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-ramp_time" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will run the specified workload for this amount of time before
logging any performance numbers. Useful for letting performance settle
before logging results, thus minimizing the runtime required for stable
results. Note that the <code class="docutils literal"><span class="pre">ramp_time</span></code> is considered lead in time for a job,
thus it will increase the total runtime if a special timeout or
<a class="reference internal" href="#cmdoption-arg-runtime"><code class="xref std std-option docutils literal"><span class="pre">runtime</span></code></a> is specified.  When the unit is omitted, the value is
given in seconds.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-clocksource">
<code class="descname">clocksource</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-clocksource" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the given clocksource as the base of timing. The supported options are:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>gettimeofday</strong></dt>
<dd><em class="manpage">gettimeofday(2)</em></dd>
<dt><strong>clock_gettime</strong></dt>
<dd><em class="manpage">clock_gettime(2)</em></dd>
<dt><strong>cpu</strong></dt>
<dd>Internal CPU clock source</dd>
</dl>
</div></blockquote>
<p>cpu is the preferred clocksource if it is reliable, as it is very fast (and
fio is heavy on time calls). Fio will automatically use this clocksource if
it&#8217;s supported and considered reliable on the system it is running on,
unless another clocksource is specifically set. For x86/x86-64 CPUs, this
means supporting TSC Invariant.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-gtod_reduce">
<code class="descname">gtod_reduce</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-gtod_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable all of the <em class="manpage">gettimeofday(2)</em> reducing options
(<a class="reference internal" href="#cmdoption-arg-disable_clat"><code class="xref std std-option docutils literal"><span class="pre">disable_clat</span></code></a>, <a class="reference internal" href="#cmdoption-arg-disable_slat"><code class="xref std std-option docutils literal"><span class="pre">disable_slat</span></code></a>, <a class="reference internal" href="#cmdoption-arg-disable_bw_measurement"><code class="xref std std-option docutils literal"><span class="pre">disable_bw_measurement</span></code></a>) plus
reduce precision of the timeout somewhat to really shrink the
<em class="manpage">gettimeofday(2)</em> call count. With this option enabled, we only do
about 0.4% of the <em class="manpage">gettimeofday(2)</em> calls we would have done if all
time keeping was enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-gtod_cpu">
<code class="descname">gtod_cpu</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-gtod_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes it&#8217;s cheaper to dedicate a single thread of execution to just
getting the current time. Fio (and databases, for instance) are very
intensive on <em class="manpage">gettimeofday(2)</em> calls. With this option, you can set
one CPU aside for doing nothing but logging current time to a shared memory
location. Then the other threads/processes that run I/O workloads need only
copy that segment, instead of entering the kernel with a
<em class="manpage">gettimeofday(2)</em> call. The CPU set aside for doing these time
calls will be excluded from other uses. Fio will manually clear it from the
CPU mask of other jobs.</p>
</dd></dl>

</div>
<div class="section" id="target-file-device">
<h3>Target file/device<a class="headerlink" href="#target-file-device" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-directory">
<code class="descname">directory</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Prefix filenames with this directory. Used to place files in a different
location than <code class="file docutils literal"><span class="pre">./</span></code>.  You can specify a number of directories by
separating the names with a &#8216;:&#8217; character. These directories will be
assigned equally distributed to job clones creates with <a class="reference internal" href="#cmdoption-arg-numjobs"><code class="xref std std-option docutils literal"><span class="pre">numjobs</span></code></a> as
long as they are using generated filenames. If specific <cite>filename(s)</cite> are
set fio will use the first listed directory, and thereby matching the
<cite>filename</cite> semantic which generates a file each clone if not specified, but
let all clones use the same if set.</p>
<p>See the <a class="reference internal" href="#cmdoption-arg-filename"><code class="xref std std-option docutils literal"><span class="pre">filename</span></code></a> option for escaping certain characters.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-filename">
<code class="descname">filename</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio normally makes up a <cite>filename</cite> based on the job name, thread number, and
file number. If you want to share files between threads in a job or several
jobs with fixed file paths, specify a <cite>filename</cite> for each of them to override
the default. If the ioengine is file based, you can specify a number of files
by separating the names with a &#8216;:&#8217; colon. So if you wanted a job to open
<code class="file docutils literal"><span class="pre">/dev/sda</span></code> and <code class="file docutils literal"><span class="pre">/dev/sdb</span></code> as the two working files, you would use
<code class="docutils literal"><span class="pre">filename=/dev/sda:/dev/sdb</span></code>. This also means that whenever this option is
specified, <a class="reference internal" href="#cmdoption-arg-nrfiles"><code class="xref std std-option docutils literal"><span class="pre">nrfiles</span></code></a> is ignored. The size of regular files specified
by this option will be <a class="reference internal" href="#cmdoption-arg-size"><code class="xref std std-option docutils literal"><span class="pre">size</span></code></a> divided by number of files unless
explicit size is specified by <a class="reference internal" href="#cmdoption-arg-filesize"><code class="xref std std-option docutils literal"><span class="pre">filesize</span></code></a>.</p>
<p>On Windows, disk devices are accessed as <code class="file docutils literal"><span class="pre">\\.\PhysicalDrive0</span></code> for
the first device, <code class="file docutils literal"><span class="pre">\\.\PhysicalDrive1</span></code> for the second etc.
Note: Windows and FreeBSD prevent write access to areas
of the disk containing in-use data (e.g. filesystems).  If the wanted
<cite>filename</cite> does need to include a colon, then escape that with a <code class="docutils literal"><span class="pre">\</span></code>
character. For instance, if the <cite>filename</cite> is <code class="file docutils literal"><span class="pre">/dev/dsk/foo&#64;3,0:c</span></code>,
then you would use <code class="docutils literal"><span class="pre">filename=&quot;/dev/dsk/foo&#64;3,0\:c&quot;</span></code>.  The
<code class="file docutils literal"><span class="pre">-</span></code> is a reserved name, meaning stdin or stdout.  Which of the two
depends on the read/write direction set.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-filename_format">
<code class="descname">filename_format</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-filename_format" title="Permalink to this definition">¶</a></dt>
<dd><p>If sharing multiple files between jobs, it is usually necessary to have fio
generate the exact names that you want. By default, fio will name a file
based on the default file format specification of
<code class="file docutils literal"><span class="pre">jobname.jobnumber.filenumber</span></code>. With this option, that can be
customized. Fio will recognize and replace the following keywords in this
string:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>$jobname</strong></dt>
<dd>The name of the worker thread or process.</dd>
<dt><strong>$jobnum</strong></dt>
<dd>The incremental number of the worker thread or process.</dd>
<dt><strong>$filenum</strong></dt>
<dd>The incremental number of the file for that worker thread or
process.</dd>
</dl>
</div></blockquote>
<p>To have dependent jobs share a set of files, this option can be set to have
fio generate filenames that are shared between the two. For instance, if
<code class="file docutils literal"><span class="pre">testfiles.$filenum</span></code> is specified, file number 4 for any job will be
named <code class="file docutils literal"><span class="pre">testfiles.4</span></code>. The default of <code class="file docutils literal"><span class="pre">$jobname.$jobnum.$filenum</span></code>
will be used if no other format specifier is given.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-unique_filename">
<code class="descname">unique_filename</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-unique_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>To avoid collisions between networked clients, fio defaults to prefixing any
generated filenames (with a directory specified) with the source of the
client connecting. To disable this behavior, set this option to 0.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-opendir">
<code class="descname">opendir</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-opendir" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively open any files below directory <cite>str</cite>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-lockfile">
<code class="descname">lockfile</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-lockfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio defaults to not locking any files before it does I/O to them. If a file
or file descriptor is shared, fio can serialize I/O to that file to make the
end result consistent. This is usual for emulating real workloads that share
files. The lock modes are:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>none</strong></dt>
<dd>No locking. The default.</dd>
<dt><strong>exclusive</strong></dt>
<dd>Only one thread or process may do I/O at a time, excluding all
others.</dd>
<dt><strong>readwrite</strong></dt>
<dd>Read-write locking on the file. Many readers may
access the file at the same time, but writes get exclusive access.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-nrfiles">
<code class="descname">nrfiles</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-nrfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of files to use for this job. Defaults to 1. The size of files
will be <a class="reference internal" href="#cmdoption-arg-size"><code class="xref std std-option docutils literal"><span class="pre">size</span></code></a> divided by this unless explicit size is specified by
<a class="reference internal" href="#cmdoption-arg-filesize"><code class="xref std std-option docutils literal"><span class="pre">filesize</span></code></a>. Files are created for each thread separately, and each
file will have a file number within its name by default, as explained in
<a class="reference internal" href="#cmdoption-arg-filename"><code class="xref std std-option docutils literal"><span class="pre">filename</span></code></a> section.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-openfiles">
<code class="descname">openfiles</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-openfiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of files to keep open at the same time. Defaults to the same as
<a class="reference internal" href="#cmdoption-arg-nrfiles"><code class="xref std std-option docutils literal"><span class="pre">nrfiles</span></code></a>, can be set smaller to limit the number simultaneous
opens.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-file_service_type">
<code class="descname">file_service_type</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-file_service_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines how fio decides which file from a job to service next. The following
types are defined:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>random</strong></dt>
<dd>Choose a file at random.</dd>
<dt><strong>roundrobin</strong></dt>
<dd>Round robin over opened files. This is the default.</dd>
<dt><strong>sequential</strong></dt>
<dd>Finish one file before moving on to the next. Multiple files can
still be open depending on &#8216;openfiles&#8217;.</dd>
<dt><strong>zipf</strong></dt>
<dd>Use a <em>Zipf</em> distribution to decide what file to access.</dd>
<dt><strong>pareto</strong></dt>
<dd>Use a <em>Pareto</em> distribution to decide what file to access.</dd>
<dt><strong>gauss</strong></dt>
<dd>Use a <em>Gaussian</em> (normal) distribution to decide what file to
access.</dd>
</dl>
</div></blockquote>
<p>For <em>random</em>, <em>roundrobin</em>, and <em>sequential</em>, a postfix can be appended to
tell fio how many I/Os to issue before switching to a new file. For example,
specifying <code class="docutils literal"><span class="pre">file_service_type=random:8</span></code> would cause fio to issue
8 I/Os before selecting a new file at random. For the non-uniform
distributions, a floating point postfix can be given to influence how the
distribution is skewed. See <a class="reference internal" href="#cmdoption-arg-random_distribution"><code class="xref std std-option docutils literal"><span class="pre">random_distribution</span></code></a> for a description
of how that would work.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ioscheduler">
<code class="descname">ioscheduler</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-ioscheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to switch the device hosting the file to the specified I/O scheduler
before running.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-create_serialize">
<code class="descname">create_serialize</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-create_serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, serialize the file creation for the jobs.  This may be handy to
avoid interleaving of data files, which may greatly depend on the filesystem
used and even the number of processors in the system.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-create_fsync">
<code class="descname">create_fsync</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-create_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>fsync the data file after creation. This is the default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-create_on_open">
<code class="descname">create_on_open</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-create_on_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Don&#8217;t pre-setup the files for I/O, just create open() when it&#8217;s time to do
I/O to that file.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-create_only">
<code class="descname">create_only</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-create_only" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, fio will only run the setup phase of the job.  If files need to be
laid out or updated on disk, only that will be done. The actual job contents
are not executed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-allow_file_create">
<code class="descname">allow_file_create</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-allow_file_create" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, fio is permitted to create files as part of its workload. This is
the default behavior. If this option is false, then fio will error out if
the files it needs to use don&#8217;t already exist. Default: true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-allow_mounted_write">
<code class="descname">allow_mounted_write</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-allow_mounted_write" title="Permalink to this definition">¶</a></dt>
<dd><p>If this isn&#8217;t set, fio will abort jobs that are destructive (e.g. that write)
to what appears to be a mounted device or partition. This should help catch
creating inadvertently destructive tests, not realizing that the test will
destroy data on the mounted file system. Note that some platforms don&#8217;t allow
writing against a mounted device regardless of this option. Default: false.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-pre_read">
<code class="descname">pre_read</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-pre_read" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is given, files will be pre-read into memory before starting the
given I/O operation. This will also clear the <a class="reference internal" href="#cmdoption-arg-invalidate"><code class="xref std std-option docutils literal"><span class="pre">invalidate</span></code></a> flag,
since it is pointless to pre-read and then drop the cache. This will only
work for I/O engines that are seek-able, since they allow you to read the
same data multiple times. Thus it will not work on e.g. network or splice I/O.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-unlink">
<code class="descname">unlink</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlink the job files when done. Not the default, as repeated runs of that
job would then waste time recreating the file set again and again.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-unlink_each_loop">
<code class="descname">unlink_each_loop</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-unlink_each_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlink job files after each iteration or loop.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-zonesize">
<code class="descname">zonesize</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-zonesize" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide a file into zones of the specified size. See <a class="reference internal" href="#cmdoption-arg-zoneskip"><code class="xref std std-option docutils literal"><span class="pre">zoneskip</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-zonerange">
<code class="descname">zonerange</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-zonerange" title="Permalink to this definition">¶</a></dt>
<dd><p>Give size of an I/O zone.  See <a class="reference internal" href="#cmdoption-arg-zoneskip"><code class="xref std std-option docutils literal"><span class="pre">zoneskip</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-zoneskip">
<code class="descname">zoneskip</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-zoneskip" title="Permalink to this definition">¶</a></dt>
<dd><p>Skip the specified number of bytes when <a class="reference internal" href="#cmdoption-arg-zonesize"><code class="xref std std-option docutils literal"><span class="pre">zonesize</span></code></a> data has been
read. The two zone options can be used to only do I/O on zones of a file.</p>
</dd></dl>

</div>
<div class="section" id="i-o-type">
<h3>I/O type<a class="headerlink" href="#i-o-type" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-direct">
<code class="descname">direct</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-direct" title="Permalink to this definition">¶</a></dt>
<dd><p>If value is true, use non-buffered I/O. This is usually O_DIRECT. Note that
ZFS on Solaris doesn&#8217;t support direct I/O.  On Windows the synchronous
ioengines don&#8217;t support direct I/O.  Default: false.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-atomic">
<code class="descname">atomic</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>If value is true, attempt to use atomic direct I/O. Atomic writes are
guaranteed to be stable once acknowledged by the operating system. Only
Linux supports O_ATOMIC right now.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-buffered">
<code class="descname">buffered</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-buffered" title="Permalink to this definition">¶</a></dt>
<dd><p>If value is true, use buffered I/O. This is the opposite of the
<a class="reference internal" href="#cmdoption-arg-direct"><code class="xref std std-option docutils literal"><span class="pre">direct</span></code></a> option. Defaults to true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-readwrite">
<span id="cmdoption-arg-rw"></span><code class="descname">readwrite</code><code class="descclassname">=str</code><code class="descclassname">, </code><code class="descname">rw</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-readwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of I/O pattern. Accepted values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>read</strong></dt>
<dd>Sequential reads.</dd>
<dt><strong>write</strong></dt>
<dd>Sequential writes.</dd>
<dt><strong>trim</strong></dt>
<dd>Sequential trims (Linux block devices only).</dd>
<dt><strong>randwrite</strong></dt>
<dd>Random writes.</dd>
<dt><strong>randread</strong></dt>
<dd>Random reads.</dd>
<dt><strong>randtrim</strong></dt>
<dd>Random trims (Linux block devices only).</dd>
<dt><strong>rw,readwrite</strong></dt>
<dd>Sequential mixed reads and writes.</dd>
<dt><strong>randrw</strong></dt>
<dd>Random mixed reads and writes.</dd>
<dt><strong>trimwrite</strong></dt>
<dd>Sequential trim+write sequences. Blocks will be trimmed first,
then the same blocks will be written to.</dd>
</dl>
</div></blockquote>
<p>Fio defaults to read if the option is not specified.  For the mixed I/O
types, the default is to split them 50/50.  For certain types of I/O the
result may still be skewed a bit, since the speed may be different. It is
possible to specify a number of I/O&#8217;s to do before getting a new offset,
this is done by appending a <code class="docutils literal"><span class="pre">:&lt;nr&gt;</span></code> to the end of the string given.  For a
random read, it would look like <code class="docutils literal"><span class="pre">rw=randread:8</span></code> for passing in an offset
modifier with a value of 8. If the suffix is used with a sequential I/O
pattern, then the value specified will be added to the generated offset for
each I/O.  For instance, using <code class="docutils literal"><span class="pre">rw=write:4k</span></code> will skip 4k for every
write. It turns sequential I/O into sequential I/O with holes.  See the
<a class="reference internal" href="#cmdoption-arg-rw_sequencer"><code class="xref std std-option docutils literal"><span class="pre">rw_sequencer</span></code></a> option.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rw_sequencer">
<code class="descname">rw_sequencer</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-rw_sequencer" title="Permalink to this definition">¶</a></dt>
<dd><p>If an offset modifier is given by appending a number to the <code class="docutils literal"><span class="pre">rw=&lt;str&gt;</span></code>
line, then this option controls how that number modifies the I/O offset
being generated. Accepted values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>sequential</strong></dt>
<dd>Generate sequential offset.</dd>
<dt><strong>identical</strong></dt>
<dd>Generate the same offset.</dd>
</dl>
</div></blockquote>
<p><code class="docutils literal"><span class="pre">sequential</span></code> is only useful for random I/O, where fio would normally
generate a new random offset for every I/O. If you append e.g. 8 to randread,
you would get a new random offset for every 8 I/O&#8217;s. The result would be a
seek for only every 8 I/O&#8217;s, instead of for every I/O. Use <code class="docutils literal"><span class="pre">rw=randread:8</span></code>
to specify that. As sequential I/O is already sequential, setting
<code class="docutils literal"><span class="pre">sequential</span></code> for that would not result in any differences.  <code class="docutils literal"><span class="pre">identical</span></code>
behaves in a similar fashion, except it sends the same offset 8 number of
times before generating a new offset.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-unified_rw_reporting">
<code class="descname">unified_rw_reporting</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-unified_rw_reporting" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio normally reports statistics on a per data direction basis, meaning that
reads, writes, and trims are accounted and reported separately. If this
option is set fio sums the results and report them as &#8220;mixed&#8221; instead.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-randrepeat">
<code class="descname">randrepeat</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-randrepeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Seed the random number generator used for random I/O patterns in a
predictable way so the pattern is repeatable across runs. Default: true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-allrandrepeat">
<code class="descname">allrandrepeat</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-allrandrepeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Seed all random number generators in a predictable way so results are
repeatable across runs.  Default: false.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-randseed">
<code class="descname">randseed</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-randseed" title="Permalink to this definition">¶</a></dt>
<dd><p>Seed the random number generators based on this seed value, to be able to
control what sequence of output is being generated.  If not set, the random
sequence depends on the <a class="reference internal" href="#cmdoption-arg-randrepeat"><code class="xref std std-option docutils literal"><span class="pre">randrepeat</span></code></a> setting.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fallocate">
<code class="descname">fallocate</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-fallocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether pre-allocation is performed when laying down files.
Accepted values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>none</strong></dt>
<dd>Do not pre-allocate space.</dd>
<dt><strong>posix</strong></dt>
<dd>Pre-allocate via <em class="manpage">posix_fallocate(3)</em>.</dd>
<dt><strong>keep</strong></dt>
<dd>Pre-allocate via <em class="manpage">fallocate(2)</em> with
FALLOC_FL_KEEP_SIZE set.</dd>
<dt><strong>0</strong></dt>
<dd>Backward-compatible alias for <strong>none</strong>.</dd>
<dt><strong>1</strong></dt>
<dd>Backward-compatible alias for <strong>posix</strong>.</dd>
</dl>
</div></blockquote>
<p>May not be available on all supported platforms. <strong>keep</strong> is only available
on Linux. If using ZFS on Solaris this must be set to <strong>none</strong> because ZFS
doesn&#8217;t support it. Default: <strong>posix</strong>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fadvise_hint">
<code class="descname">fadvise_hint</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-fadvise_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>Use <em class="manpage">posix_fadvise(2)</em> to advise the kernel on what I/O patterns
are likely to be issued.  Accepted values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>0</strong></dt>
<dd>Backwards-compatible hint for &#8220;no hint&#8221;.</dd>
<dt><strong>1</strong></dt>
<dd>Backwards compatible hint for &#8220;advise with fio workload type&#8221;. This
uses <strong>FADV_RANDOM</strong> for a random workload, and <strong>FADV_SEQUENTIAL</strong>
for a sequential workload.</dd>
<dt><strong>sequential</strong></dt>
<dd>Advise using <strong>FADV_SEQUENTIAL</strong>.</dd>
<dt><strong>random</strong></dt>
<dd>Advise using <strong>FADV_RANDOM</strong>.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fadvise_stream">
<code class="descname">fadvise_stream</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-fadvise_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Use <em class="manpage">posix_fadvise(2)</em> to advise the kernel what stream ID the
writes issued belong to. Only supported on Linux. Note, this option may
change going forward.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-offset">
<code class="descname">offset</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Start I/O at the given offset in the file. The data before the given offset
will not be touched. This effectively caps the file size at <cite>real_size -
offset</cite>. Can be combined with <a class="reference internal" href="#cmdoption-arg-size"><code class="xref std std-option docutils literal"><span class="pre">size</span></code></a> to constrain the start and
end range that I/O will be done within.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-offset_increment">
<code class="descname">offset_increment</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-offset_increment" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is provided, then the real offset becomes <cite>offset + offset_increment
* thread_number</cite>, where the thread number is a counter that starts at 0 and
is incremented for each sub-job (i.e. when <a class="reference internal" href="#cmdoption-arg-numjobs"><code class="xref std std-option docutils literal"><span class="pre">numjobs</span></code></a> option is
specified). This option is useful if there are several jobs which are
intended to operate on a file in parallel disjoint segments, with even
spacing between the starting points.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-number_ios">
<code class="descname">number_ios</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-number_ios" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio will normally perform I/Os until it has exhausted the size of the region
set by <a class="reference internal" href="#cmdoption-arg-size"><code class="xref std std-option docutils literal"><span class="pre">size</span></code></a>, or if it exhaust the allocated time (or hits an error
condition). With this setting, the range/size can be set independently of
the number of I/Os to perform. When fio reaches this number, it will exit
normally and report status. Note that this does not extend the amount of I/O
that will be done, it will only stop fio if this condition is met before
other end-of-job criteria.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fsync">
<code class="descname">fsync</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>If writing to a file, issue a sync of the dirty data for every number of
blocks given. For example, if you give 32 as a parameter, fio will sync the
file for every 32 writes issued. If fio is using non-buffered I/O, we may
not sync the file. The exception is the sg I/O engine, which synchronizes
the disk cache anyway.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fdatasync">
<code class="descname">fdatasync</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-fdatasync" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#cmdoption-arg-fsync"><code class="xref std std-option docutils literal"><span class="pre">fsync</span></code></a> but uses <em class="manpage">fdatasync(2)</em> to only sync data and
not metadata blocks.  In Windows, FreeBSD, and DragonFlyBSD there is no
<em class="manpage">fdatasync(2)</em>, this falls back to using <em class="manpage">fsync(2)</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-write_barrier">
<code class="descname">write_barrier</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-write_barrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Make every <cite>N-th</cite> write a barrier write.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-sync_file_range">
<code class="descname">sync_file_range</code><code class="descclassname">=str:val</code><a class="headerlink" href="#cmdoption-arg-sync_file_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Use <em class="manpage">sync_file_range(2)</em> for every <cite>val</cite> number of write
operations. Fio will track range of writes that have happened since the last
<em class="manpage">sync_file_range(2)</em> call. <cite>str</cite> can currently be one or more of:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>wait_before</strong></dt>
<dd>SYNC_FILE_RANGE_WAIT_BEFORE</dd>
<dt><strong>write</strong></dt>
<dd>SYNC_FILE_RANGE_WRITE</dd>
<dt><strong>wait_after</strong></dt>
<dd>SYNC_FILE_RANGE_WAIT_AFTER</dd>
</dl>
</div></blockquote>
<p>So if you do <code class="docutils literal"><span class="pre">sync_file_range=wait_before,write:8</span></code>, fio would use
<code class="docutils literal"><span class="pre">SYNC_FILE_RANGE_WAIT_BEFORE</span> <span class="pre">|</span> <span class="pre">SYNC_FILE_RANGE_WRITE</span></code> for every 8
writes. Also see the <em class="manpage">sync_file_range(2)</em> man page.  This option is
Linux specific.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-overwrite">
<code class="descname">overwrite</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-overwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, writes to a file will always overwrite existing data. If the file
doesn&#8217;t already exist, it will be created before the write phase begins. If
the file exists and is large enough for the specified write phase, nothing
will be done.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-end_fsync">
<code class="descname">end_fsync</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-end_fsync" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, fsync file contents when a write stage has completed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fsync_on_close">
<code class="descname">fsync_on_close</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-fsync_on_close" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, fio will <em class="manpage">fsync(2)</em> a dirty file on close.  This differs
from end_fsync in that it will happen on every file close, not just at the
end of the job.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rwmixread">
<code class="descname">rwmixread</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-rwmixread" title="Permalink to this definition">¶</a></dt>
<dd><p>Percentage of a mixed workload that should be reads. Default: 50.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rwmixwrite">
<code class="descname">rwmixwrite</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-rwmixwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Percentage of a mixed workload that should be writes. If both
<a class="reference internal" href="#cmdoption-arg-rwmixread"><code class="xref std std-option docutils literal"><span class="pre">rwmixread</span></code></a> and <a class="reference internal" href="#cmdoption-arg-rwmixwrite"><code class="xref std std-option docutils literal"><span class="pre">rwmixwrite</span></code></a> is given and the values do not
add up to 100%, the latter of the two will be used to override the
first. This may interfere with a given rate setting, if fio is asked to
limit reads or writes to a certain rate.  If that is the case, then the
distribution may be skewed. Default: 50.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-random_distribution">
<code class="descname">random_distribution</code><code class="descclassname">=str:float[,str:float][,str:float]</code><a class="headerlink" href="#cmdoption-arg-random_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, fio will use a completely uniform random distribution when asked
to perform random I/O. Sometimes it is useful to skew the distribution in
specific ways, ensuring that some parts of the data is more hot than others.
fio includes the following distribution models:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>random</strong></dt>
<dd>Uniform random distribution</dd>
<dt><strong>zipf</strong></dt>
<dd>Zipf distribution</dd>
<dt><strong>pareto</strong></dt>
<dd>Pareto distribution</dd>
<dt><strong>gauss</strong></dt>
<dd>Normal (Gaussian) distribution</dd>
<dt><strong>zoned</strong></dt>
<dd>Zoned random distribution</dd>
</dl>
</div></blockquote>
<p>When using a <strong>zipf</strong> or <strong>pareto</strong> distribution, an input value is also
needed to define the access pattern. For <strong>zipf</strong>, this is the <cite>zipf
theta</cite>. For <strong>pareto</strong>, it&#8217;s the <cite>Pareto power</cite>. Fio includes a test
program, <strong class="command">genzipf</strong>, that can be used visualize what the given input
values will yield in terms of hit rates.  If you wanted to use <strong>zipf</strong> with
a <cite>theta</cite> of 1.2, you would use <code class="docutils literal"><span class="pre">random_distribution=zipf:1.2</span></code> as the
option. If a non-uniform model is used, fio will disable use of the random
map. For the <strong>gauss</strong> distribution, a normal deviation is supplied as a
value between 0 and 100.</p>
<p>For a <strong>zoned</strong> distribution, fio supports specifying percentages of I/O
access that should fall within what range of the file or device. For
example, given a criteria of:</p>
<ul class="simple">
<li>60% of accesses should be to the first 10%</li>
<li>30% of accesses should be to the next 20%</li>
<li>8% of accesses should be to to the next 30%</li>
<li>2% of accesses should be to the next 40%</li>
</ul>
<p>we can define that through zoning of the random accesses. For the above
example, the user would do:</p>
<div class="highlight-python"><div class="highlight"><pre>random_distribution=zoned:60/10:30/20:8/30:2/40
</pre></div>
</div>
<p>similarly to how <a class="reference internal" href="#cmdoption-arg-bssplit"><code class="xref std std-option docutils literal"><span class="pre">bssplit</span></code></a> works for setting ranges and percentages
of block sizes. Like <a class="reference internal" href="#cmdoption-arg-bssplit"><code class="xref std std-option docutils literal"><span class="pre">bssplit</span></code></a>, it&#8217;s possible to specify separate
zones for reads, writes, and trims. If just one set is given, it&#8217;ll apply to
all of them.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-percentage_random">
<code class="descname">percentage_random</code><code class="descclassname">=int[,int][,int]</code><a class="headerlink" href="#cmdoption-arg-percentage_random" title="Permalink to this definition">¶</a></dt>
<dd><p>For a random workload, set how big a percentage should be random. This
defaults to 100%, in which case the workload is fully random. It can be set
from anywhere from 0 to 100.  Setting it to 0 would make the workload fully
sequential. Any setting in between will result in a random mix of sequential
and random I/O, at the given percentages.  Comma-separated values may be
specified for reads, writes, and trims as described in <a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-norandommap">
<code class="descname">norandommap</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-norandommap" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally fio will cover every block of the file when doing random I/O. If
this option is given, fio will just get a new random offset without looking
at past I/O history. This means that some blocks may not be read or written,
and that some blocks may be read/written more than once. If this option is
used with <a class="reference internal" href="#cmdoption-arg-verify"><code class="xref std std-option docutils literal"><span class="pre">verify</span></code></a> and multiple blocksizes (via <a class="reference internal" href="#cmdoption-arg-bsrange"><code class="xref std std-option docutils literal"><span class="pre">bsrange</span></code></a>),
only intact blocks are verified, i.e., partially-overwritten blocks are
ignored.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-softrandommap">
<code class="descname">softrandommap</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-softrandommap" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#cmdoption-arg-norandommap"><code class="xref std std-option docutils literal"><span class="pre">norandommap</span></code></a>. If fio runs with the random block map enabled and
it fails to allocate the map, if this option is set it will continue without
a random block map. As coverage will not be as complete as with random maps,
this option is disabled by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-random_generator">
<code class="descname">random_generator</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-random_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio supports the following engines for generating
I/O offsets for random I/O:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>tausworthe</strong></dt>
<dd>Strong 2^88 cycle random number generator</dd>
<dt><strong>lfsr</strong></dt>
<dd>Linear feedback shift register generator</dd>
<dt><strong>tausworthe64</strong></dt>
<dd>Strong 64-bit 2^258 cycle random number generator</dd>
</dl>
</div></blockquote>
<p><strong>tausworthe</strong> is a strong random number generator, but it requires tracking
on the side if we want to ensure that blocks are only read or written
once. <strong>LFSR</strong> guarantees that we never generate the same offset twice, and
it&#8217;s also less computationally expensive. It&#8217;s not a true random generator,
however, though for I/O purposes it&#8217;s typically good enough. <strong>LFSR</strong> only
works with single block sizes, not with workloads that use multiple block
sizes. If used with such a workload, fio may read or write some blocks
multiple times. The default value is <strong>tausworthe</strong>, unless the required
space exceeds 2^32 blocks. If it does, then <strong>tausworthe64</strong> is
selected automatically.</p>
</dd></dl>

</div>
<div class="section" id="block-size">
<h3>Block size<a class="headerlink" href="#block-size" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-blocksize">
<span id="cmdoption-arg-bs"></span><code class="descname">blocksize</code><code class="descclassname">=int[,int][,int]</code><code class="descclassname">, </code><code class="descname">bs</code><code class="descclassname">=int[,int][,int]</code><a class="headerlink" href="#cmdoption-arg-blocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>The block size in bytes used for I/O units. Default: 4096.  A single value
applies to reads, writes, and trims.  Comma-separated values may be
specified for reads, writes, and trims.  A value not terminated in a comma
applies to subsequent types.</p>
<p>Examples:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>bs=256k</strong></dt>
<dd>means 256k for reads, writes and trims.</dd>
<dt><strong>bs=8k,32k</strong></dt>
<dd>means 8k for reads, 32k for writes and trims.</dd>
<dt><strong>bs=8k,32k,</strong></dt>
<dd>means 8k for reads, 32k for writes, and default for trims.</dd>
<dt><strong>bs=,8k</strong></dt>
<dd>means default for reads, 8k for writes and trims.</dd>
<dt><strong>bs=,8k,</strong></dt>
<dd>means default for reads, 8k for writes, and default for writes.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-blocksize_range">
<span id="cmdoption-arg-bsrange"></span><code class="descname">blocksize_range</code><code class="descclassname">=irange[,irange][,irange]</code><code class="descclassname">, </code><code class="descname">bsrange</code><code class="descclassname">=irange[,irange][,irange]</code><a class="headerlink" href="#cmdoption-arg-blocksize_range" title="Permalink to this definition">¶</a></dt>
<dd><p>A range of block sizes in bytes for I/O units.  The issued I/O unit will
always be a multiple of the minimum size, unless
<a class="reference internal" href="#cmdoption-arg-blocksize_unaligned"><code class="xref std std-option docutils literal"><span class="pre">blocksize_unaligned</span></code></a> is set.</p>
<p>Comma-separated ranges may be specified for reads, writes, and trims as
described in <a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>.</p>
<p>Example: <code class="docutils literal"><span class="pre">bsrange=1k-4k,2k-8k</span></code>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-bssplit">
<code class="descname">bssplit</code><code class="descclassname">=str[,str][,str]</code><a class="headerlink" href="#cmdoption-arg-bssplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes you want even finer grained control of the block sizes issued, not
just an even split between them.  This option allows you to weight various
block sizes, so that you are able to define a specific amount of block sizes
issued. The format for this option is:</p>
<div class="highlight-python"><div class="highlight"><pre>bssplit=blocksize/percentage:blocksize/percentage
</pre></div>
</div>
<p>for as many block sizes as needed. So if you want to define a workload that
has 50% 64k blocks, 10% 4k blocks, and 40% 32k blocks, you would write:</p>
<div class="highlight-python"><div class="highlight"><pre>bssplit=4k/10:64k/50:32k/40
</pre></div>
</div>
<p>Ordering does not matter. If the percentage is left blank, fio will fill in
the remaining values evenly. So a bssplit option like this one:</p>
<div class="highlight-python"><div class="highlight"><pre>bssplit=4k/50:1k/:32k/
</pre></div>
</div>
<p>would have 50% 4k ios, and 25% 1k and 32k ios. The percentages always add up
to 100, if bssplit is given a range that adds up to more, it will error out.</p>
<p>Comma-separated values may be specified for reads, writes, and trims as
described in <a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>.</p>
<p>If you want a workload that has 50% 2k reads and 50% 4k reads, while having
90% 4k writes and 10% 8k writes, you would specify:</p>
<div class="highlight-python"><div class="highlight"><pre>bssplit=2k/50:4k/50,4k/90,8k/10
</pre></div>
</div>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-blocksize_unaligned">
<span id="cmdoption-arg-bs_unaligned"></span><code class="descname">blocksize_unaligned</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">bs_unaligned</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-blocksize_unaligned" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will issue I/O units with any size within
<a class="reference internal" href="#cmdoption-arg-blocksize_range"><code class="xref std std-option docutils literal"><span class="pre">blocksize_range</span></code></a>, not just multiples of the minimum size.  This
typically won&#8217;t work with direct I/O, as that normally requires sector
alignment.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-bs_is_seq_rand">
<code class="descname">bs_is_seq_rand</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-bs_is_seq_rand" title="Permalink to this definition">¶</a></dt>
<dd><p>If this option is set, fio will use the normal read,write blocksize settings
as sequential,random blocksize settings instead. Any random read or write
will use the WRITE blocksize settings, and any sequential read or write will
use the READ blocksize settings.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-blockalign">
<span id="cmdoption-arg-ba"></span><code class="descname">blockalign</code><code class="descclassname">=int[,int][,int]</code><code class="descclassname">, </code><code class="descname">ba</code><code class="descclassname">=int[,int][,int]</code><a class="headerlink" href="#cmdoption-arg-blockalign" title="Permalink to this definition">¶</a></dt>
<dd><p>Boundary to which fio will align random I/O units.  Default:
<a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>.  Minimum alignment is typically 512b for using direct
I/O, though it usually depends on the hardware block size. This option is
mutually exclusive with using a random map for files, so it will turn off
that option.  Comma-separated values may be specified for reads, writes, and
trims as described in <a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="buffers-and-memory">
<h3>Buffers and memory<a class="headerlink" href="#buffers-and-memory" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-zero_buffers">
<code class="descname">zero_buffers</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-zero_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize buffers with all zeros. Default: fill buffers with random data.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-refill_buffers">
<code class="descname">refill_buffers</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-refill_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>If this option is given, fio will refill the I/O buffers on every
submit. The default is to only fill it at init time and reuse that
data. Only makes sense if zero_buffers isn&#8217;t specified, naturally. If data
verification is enabled, <cite>refill_buffers</cite> is also automatically enabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-scramble_buffers">
<code class="descname">scramble_buffers</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-scramble_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>If <a class="reference internal" href="#cmdoption-arg-refill_buffers"><code class="xref std std-option docutils literal"><span class="pre">refill_buffers</span></code></a> is too costly and the target is using data
deduplication, then setting this option will slightly modify the I/O buffer
contents to defeat normal de-dupe attempts. This is not enough to defeat
more clever block compression attempts, but it will stop naive dedupe of
blocks. Default: true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-buffer_compress_percentage">
<code class="descname">buffer_compress_percentage</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-buffer_compress_percentage" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is set, then fio will attempt to provide I/O buffer content (on
WRITEs) that compress to the specified level. Fio does this by providing a
mix of random data and a fixed pattern. The fixed pattern is either zeroes,
or the pattern specified by <a class="reference internal" href="#cmdoption-arg-buffer_pattern"><code class="xref std std-option docutils literal"><span class="pre">buffer_pattern</span></code></a>. If the pattern option
is used, it might skew the compression ratio slightly. Note that this is per
block size unit, for file/disk wide compression level that matches this
setting, you&#8217;ll also want to set <a class="reference internal" href="#cmdoption-arg-refill_buffers"><code class="xref std std-option docutils literal"><span class="pre">refill_buffers</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-buffer_compress_chunk">
<code class="descname">buffer_compress_chunk</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-buffer_compress_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#cmdoption-arg-buffer_compress_percentage"><code class="xref std std-option docutils literal"><span class="pre">buffer_compress_percentage</span></code></a>. This setting allows fio to manage
how big the ranges of random data and zeroed data is. Without this set, fio
will provide <a class="reference internal" href="#cmdoption-arg-buffer_compress_percentage"><code class="xref std std-option docutils literal"><span class="pre">buffer_compress_percentage</span></code></a> of blocksize random data,
followed by the remaining zeroed. With this set to some chunk size smaller
than the block size, fio can alternate random and zeroed data throughout the
I/O buffer.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-buffer_pattern">
<code class="descname">buffer_pattern</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-buffer_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will fill the I/O buffers with this pattern. If not set, the
contents of I/O buffers is defined by the other options related to buffer
contents. The setting can be any pattern of bytes, and can be prefixed with
0x for hex values. It may also be a string, where the string must then be
wrapped with <code class="docutils literal"><span class="pre">&quot;&quot;</span></code>, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">buffer_pattern</span><span class="o">=</span><span class="s2">&quot;abcd&quot;</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">buffer_pattern</span><span class="o">=-</span><span class="mi">12</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">buffer_pattern</span><span class="o">=</span><span class="mh">0xdeadface</span>
</pre></div>
</div>
<p>Also you can combine everything together in any order:</p>
<div class="highlight-python"><div class="highlight"><pre>buffer_pattern=0xdeadface&quot;abcd&quot;-12
</pre></div>
</div>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-dedupe_percentage">
<code class="descname">dedupe_percentage</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-dedupe_percentage" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will generate this percentage of identical buffers when
writing. These buffers will be naturally dedupable. The contents of the
buffers depend on what other buffer compression settings have been set. It&#8217;s
possible to have the individual buffers either fully compressible, or not at
all. This option only controls the distribution of unique buffers.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-invalidate">
<code class="descname">invalidate</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidate the buffer/page cache parts for this file prior to starting
I/O if the platform and file type support it. Defaults to true.
This will be ignored if <a class="reference internal" href="#cmdoption-arg-pre_read"><code class="xref std std-option docutils literal"><span class="pre">pre_read</span></code></a> is also specified for the
same job.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-sync">
<code class="descname">sync</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Use synchronous I/O for buffered writes. For the majority of I/O engines,
this means using O_SYNC. Default: false.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iomem">
<span id="cmdoption-arg-mem"></span><code class="descname">iomem</code><code class="descclassname">=str</code><code class="descclassname">, </code><code class="descname">mem</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-iomem" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio can use various types of memory as the I/O unit buffer.  The allowed
values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>malloc</strong></dt>
<dd>Use memory from <em class="manpage">malloc(3)</em> as the buffers.  Default memory
type.</dd>
<dt><strong>shm</strong></dt>
<dd>Use shared memory as the buffers. Allocated through
<em class="manpage">shmget(2)</em>.</dd>
<dt><strong>shmhuge</strong></dt>
<dd>Same as shm, but use huge pages as backing.</dd>
<dt><strong>mmap</strong></dt>
<dd>Use mmap to allocate buffers. May either be anonymous memory, or can
be file backed if a filename is given after the option. The format
is <cite>mem=mmap:/path/to/file</cite>.</dd>
<dt><strong>mmaphuge</strong></dt>
<dd>Use a memory mapped huge file as the buffer backing. Append filename
after mmaphuge, ala <cite>mem=mmaphuge:/hugetlbfs/file</cite>.</dd>
<dt><strong>mmapshared</strong></dt>
<dd>Same as mmap, but use a MMAP_SHARED mapping.</dd>
</dl>
</div></blockquote>
<p>The area allocated is a function of the maximum allowed bs size for the job,
multiplied by the I/O depth given. Note that for <strong>shmhuge</strong> and
<strong>mmaphuge</strong> to work, the system must have free huge pages allocated. This
can normally be checked and set by reading/writing
<code class="file docutils literal"><span class="pre">/proc/sys/vm/nr_hugepages</span></code> on a Linux system. Fio assumes a huge page
is 4MiB in size. So to calculate the number of huge pages you need for a
given job file, add up the I/O depth of all jobs (normally one unless
<a class="reference internal" href="#cmdoption-arg-iodepth"><code class="xref std std-option docutils literal"><span class="pre">iodepth</span></code></a> is used) and multiply by the maximum bs set. Then divide
that number by the huge page size. You can see the size of the huge pages in
<code class="file docutils literal"><span class="pre">/proc/meminfo</span></code>. If no huge pages are allocated by having a non-zero
number in <cite>nr_hugepages</cite>, using <strong>mmaphuge</strong> or <strong>shmhuge</strong> will fail. Also
see <a class="reference internal" href="#cmdoption-arg-hugepage-size"><code class="xref std std-option docutils literal"><span class="pre">hugepage-size</span></code></a>.</p>
<p><strong>mmaphuge</strong> also needs to have hugetlbfs mounted and the file location
should point there. So if it&#8217;s mounted in <code class="file docutils literal"><span class="pre">/huge</span></code>, you would use
<cite>mem=mmaphuge:/huge/somefile</cite>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iomem_align">
<code class="descname">iomem_align</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iomem_align" title="Permalink to this definition">¶</a></dt>
<dd><p>This indicates the memory alignment of the I/O memory buffers.  Note that
the given alignment is applied to the first I/O unit buffer, if using
<a class="reference internal" href="#cmdoption-arg-iodepth"><code class="xref std std-option docutils literal"><span class="pre">iodepth</span></code></a> the alignment of the following buffers are given by the
<a class="reference internal" href="#cmdoption-arg-bs"><code class="xref std std-option docutils literal"><span class="pre">bs</span></code></a> used. In other words, if using a <a class="reference internal" href="#cmdoption-arg-bs"><code class="xref std std-option docutils literal"><span class="pre">bs</span></code></a> that is a
multiple of the page sized in the system, all buffers will be aligned to
this value. If using a <a class="reference internal" href="#cmdoption-arg-bs"><code class="xref std std-option docutils literal"><span class="pre">bs</span></code></a> that is not page aligned, the alignment
of subsequent I/O memory buffers is the sum of the <a class="reference internal" href="#cmdoption-arg-iomem_align"><code class="xref std std-option docutils literal"><span class="pre">iomem_align</span></code></a> and
<a class="reference internal" href="#cmdoption-arg-bs"><code class="xref std std-option docutils literal"><span class="pre">bs</span></code></a> used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-hugepage-size">
<code class="descname">hugepage-size</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-hugepage-size" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the size of a huge page. Must at least be equal to the system
setting, see <code class="file docutils literal"><span class="pre">/proc/meminfo</span></code>. Defaults to 4MiB.  Should probably
always be a multiple of megabytes, so using <code class="docutils literal"><span class="pre">hugepage-size=Xm</span></code> is the
preferred way to set this to avoid setting a non-pow-2 bad value.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-lockmem">
<code class="descname">lockmem</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-lockmem" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin the specified amount of memory with <em class="manpage">mlock(2)</em>. Can be used to
simulate a smaller amount of memory.  The amount specified is per worker.</p>
</dd></dl>

</div>
<div class="section" id="i-o-size">
<h3>I/O size<a class="headerlink" href="#i-o-size" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-size">
<code class="descname">size</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-size" title="Permalink to this definition">¶</a></dt>
<dd><p>The total size of file I/O for each thread of this job. Fio will run until
this many bytes has been transferred, unless runtime is limited by other options
(such as <a class="reference internal" href="#cmdoption-arg-runtime"><code class="xref std std-option docutils literal"><span class="pre">runtime</span></code></a>, for instance, or increased/decreased by <a class="reference internal" href="#cmdoption-arg-io_size"><code class="xref std std-option docutils literal"><span class="pre">io_size</span></code></a>).
Fio will divide this size between the available files determined by options
such as <a class="reference internal" href="#cmdoption-arg-nrfiles"><code class="xref std std-option docutils literal"><span class="pre">nrfiles</span></code></a>, <a class="reference internal" href="#cmdoption-arg-filename"><code class="xref std std-option docutils literal"><span class="pre">filename</span></code></a>, unless <a class="reference internal" href="#cmdoption-arg-filesize"><code class="xref std std-option docutils literal"><span class="pre">filesize</span></code></a> is
specified by the job. If the result of division happens to be 0, the size is
set to the physical size of the given files or devices if they exist.
If this option is not specified, fio will use the full size of the given
files or devices.  If the files do not exist, size must be given. It is also
possible to give size as a percentage between 1 and 100. If <code class="docutils literal"><span class="pre">size=20%</span></code> is
given, fio will use 20% of the full size of the given files or devices.
Can be combined with <a class="reference internal" href="#cmdoption-arg-offset"><code class="xref std std-option docutils literal"><span class="pre">offset</span></code></a> to constrain the start and end range
that I/O will be done within.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-io_size">
<span id="cmdoption-arg-io_limit"></span><code class="descname">io_size</code><code class="descclassname">=int</code><code class="descclassname">, </code><code class="descname">io_limit</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-io_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally fio operates within the region set by <a class="reference internal" href="#cmdoption-arg-size"><code class="xref std std-option docutils literal"><span class="pre">size</span></code></a>, which means
that the <a class="reference internal" href="#cmdoption-arg-size"><code class="xref std std-option docutils literal"><span class="pre">size</span></code></a> option sets both the region and size of I/O to be
performed. Sometimes that is not what you want. With this option, it is
possible to define just the amount of I/O that fio should do. For instance,
if <a class="reference internal" href="#cmdoption-arg-size"><code class="xref std std-option docutils literal"><span class="pre">size</span></code></a> is set to 20GiB and <a class="reference internal" href="#cmdoption-arg-io_size"><code class="xref std std-option docutils literal"><span class="pre">io_size</span></code></a> is set to 5GiB, fio
will perform I/O within the first 20GiB but exit when 5GiB have been
done. The opposite is also possible &#8211; if <a class="reference internal" href="#cmdoption-arg-size"><code class="xref std std-option docutils literal"><span class="pre">size</span></code></a> is set to 20GiB,
and <a class="reference internal" href="#cmdoption-arg-io_size"><code class="xref std std-option docutils literal"><span class="pre">io_size</span></code></a> is set to 40GiB, then fio will do 40GiB of I/O within
the 0..20GiB region.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-filesize">
<code class="descname">filesize</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-filesize" title="Permalink to this definition">¶</a></dt>
<dd><p>Individual file sizes. May be a range, in which case fio will select sizes
for files at random within the given range and limited to <a class="reference internal" href="#cmdoption-arg-size"><code class="xref std std-option docutils literal"><span class="pre">size</span></code></a> in
total (if that is given). If not given, each created file is the same size.
This option overrides <a class="reference internal" href="#cmdoption-arg-size"><code class="xref std std-option docutils literal"><span class="pre">size</span></code></a> in terms of file size, which means
this value is used as a fixed size or possible range of each file.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-file_append">
<code class="descname">file_append</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-file_append" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform I/O after the end of the file. Normally fio will operate within the
size of a file. If this option is set, then fio will append to the file
instead. This has identical behavior to setting <a class="reference internal" href="#cmdoption-arg-offset"><code class="xref std std-option docutils literal"><span class="pre">offset</span></code></a> to the size
of a file.  This option is ignored on non-regular files.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-fill_device">
<span id="cmdoption-arg-fill_fs"></span><code class="descname">fill_device</code><code class="descclassname">=bool</code><code class="descclassname">, </code><code class="descname">fill_fs</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-fill_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets size to something really large and waits for ENOSPC (no space left on
device) as the terminating condition. Only makes sense with sequential
write. For a read workload, the mount point will be filled first then I/O
started on the result. This option doesn&#8217;t make sense if operating on a raw
device node, since the size of that is already known by the file system.
Additionally, writing beyond end-of-device will not return ENOSPC there.</p>
</dd></dl>

</div>
<div class="section" id="i-o-engine">
<h3>I/O engine<a class="headerlink" href="#i-o-engine" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-ioengine">
<code class="descname">ioengine</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-ioengine" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines how the job issues I/O to the file. The following types are defined:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>sync</strong></dt>
<dd>Basic <em class="manpage">read(2)</em> or <em class="manpage">write(2)</em>
I/O. <em class="manpage">lseek(2)</em> is used to position the I/O location.</dd>
<dt><strong>psync</strong></dt>
<dd>Basic <em class="manpage">pread(2)</em> or <em class="manpage">pwrite(2)</em> I/O.  Default on
all supported operating systems except for Windows.</dd>
<dt><strong>vsync</strong></dt>
<dd>Basic <em class="manpage">readv(2)</em> or <em class="manpage">writev(2)</em> I/O.  Will emulate
queuing by coalescing adjacent I/Os into a single submission.</dd>
<dt><strong>pvsync</strong></dt>
<dd>Basic <em class="manpage">preadv(2)</em> or <em class="manpage">pwritev(2)</em> I/O.</dd>
<dt><strong>pvsync2</strong></dt>
<dd>Basic <em class="manpage">preadv2(2)</em> or <em class="manpage">pwritev2(2)</em> I/O.</dd>
<dt><strong>libaio</strong></dt>
<dd>Linux native asynchronous I/O. Note that Linux may only support
queued behaviour with non-buffered I/O (set <code class="docutils literal"><span class="pre">direct=1</span></code> or
<code class="docutils literal"><span class="pre">buffered=0</span></code>).
This engine defines engine specific options.</dd>
<dt><strong>posixaio</strong></dt>
<dd>POSIX asynchronous I/O using <em class="manpage">aio_read(3)</em> and
<em class="manpage">aio_write(3)</em>.</dd>
<dt><strong>solarisaio</strong></dt>
<dd>Solaris native asynchronous I/O.</dd>
<dt><strong>windowsaio</strong></dt>
<dd>Windows native asynchronous I/O.  Default on Windows.</dd>
<dt><strong>mmap</strong></dt>
<dd>File is memory mapped with <em class="manpage">mmap(2)</em> and data copied
to/from using <em class="manpage">memcpy(3)</em>.</dd>
<dt><strong>splice</strong></dt>
<dd><em class="manpage">splice(2)</em> is used to transfer the data and
<em class="manpage">vmsplice(2)</em> to transfer data from user space to the
kernel.</dd>
<dt><strong>sg</strong></dt>
<dd>SCSI generic sg v3 I/O. May either be synchronous using the SG_IO
ioctl, or if the target is an sg character device we use
<em class="manpage">read(2)</em> and <em class="manpage">write(2)</em> for asynchronous
I/O. Requires filename option to specify either block or character
devices.</dd>
<dt><strong>null</strong></dt>
<dd>Doesn&#8217;t transfer any data, just pretends to.  This is mainly used to
exercise fio itself and for debugging/testing purposes.</dd>
<dt><strong>net</strong></dt>
<dd>Transfer over the network to given <code class="docutils literal"><span class="pre">host:port</span></code>.  Depending on the
<a class="reference internal" href="#cmdoption-arg-protocol"><code class="xref std std-option docutils literal"><span class="pre">protocol</span></code></a> used, the <a class="reference internal" href="#cmdoption-arg-hostname"><code class="xref std std-option docutils literal"><span class="pre">hostname</span></code></a>, <a class="reference internal" href="#cmdoption-arg-port"><code class="xref std std-option docutils literal"><span class="pre">port</span></code></a>,
<a class="reference internal" href="#cmdoption-arg-listen"><code class="xref std std-option docutils literal"><span class="pre">listen</span></code></a> and <a class="reference internal" href="#cmdoption-arg-filename"><code class="xref std std-option docutils literal"><span class="pre">filename</span></code></a> options are used to specify
what sort of connection to make, while the <a class="reference internal" href="#cmdoption-arg-protocol"><code class="xref std std-option docutils literal"><span class="pre">protocol</span></code></a> option
determines which protocol will be used.  This engine defines engine
specific options.</dd>
<dt><strong>netsplice</strong></dt>
<dd>Like <strong>net</strong>, but uses <em class="manpage">splice(2)</em> and
<em class="manpage">vmsplice(2)</em> to map data and send/receive.
This engine defines engine specific options.</dd>
<dt><strong>cpuio</strong></dt>
<dd>Doesn&#8217;t transfer any data, but burns CPU cycles according to the
<a class="reference internal" href="#cmdoption-arg-cpuload"><code class="xref std std-option docutils literal"><span class="pre">cpuload</span></code></a> and <a class="reference internal" href="#cmdoption-arg-cpuchunks"><code class="xref std std-option docutils literal"><span class="pre">cpuchunks</span></code></a> options. Setting
<a class="reference internal" href="#cmdoption-arg-cpuload"><code class="xref std std-option docutils literal"><span class="pre">cpuload</span></code></a> =85 will cause that job to do nothing but burn 85%
of the CPU. In case of SMP machines, use <a class="reference internal" href="#cmdoption-arg-numjobs"><code class="xref std std-option docutils literal"><span class="pre">numjobs</span></code></a>
=&lt;no_of_cpu&gt; to get desired CPU usage, as the cpuload only loads a
single CPU at the desired rate. A job never finishes unless there is
at least one non-cpuio job.</dd>
<dt><strong>guasi</strong></dt>
<dd><p class="first">The GUASI I/O engine is the Generic Userspace Asyncronous Syscall
Interface approach to async I/O. See</p>
<p><a class="reference external" href="http://www.xmailserver.org/guasi-lib.html">http://www.xmailserver.org/guasi-lib.html</a></p>
<p class="last">for more info on GUASI.</p>
</dd>
<dt><strong>rdma</strong></dt>
<dd>The RDMA I/O engine supports both RDMA memory semantics
(RDMA_WRITE/RDMA_READ) and channel semantics (Send/Recv) for the
InfiniBand, RoCE and iWARP protocols.</dd>
<dt><strong>falloc</strong></dt>
<dd><p class="first">I/O engine that does regular fallocate to simulate data transfer as
fio ioengine.</p>
<dl class="last docutils">
<dt>DDIR_READ</dt>
<dd>does fallocate(,mode = FALLOC_FL_KEEP_SIZE,).</dd>
<dt>DDIR_WRITE</dt>
<dd>does fallocate(,mode = 0).</dd>
<dt>DDIR_TRIM</dt>
<dd>does fallocate(,mode = FALLOC_FL_KEEP_SIZE|FALLOC_FL_PUNCH_HOLE).</dd>
</dl>
</dd>
<dt><strong>e4defrag</strong></dt>
<dd>I/O engine that does regular EXT4_IOC_MOVE_EXT ioctls to simulate
defragment activity in request to DDIR_WRITE event.</dd>
<dt><strong>rbd</strong></dt>
<dd>I/O engine supporting direct access to Ceph Rados Block Devices
(RBD) via librbd without the need to use the kernel rbd driver. This
ioengine defines engine specific options.</dd>
<dt><strong>gfapi</strong></dt>
<dd>Using Glusterfs libgfapi sync interface to direct access to
Glusterfs volumes without having to go through FUSE.  This ioengine
defines engine specific options.</dd>
<dt><strong>gfapi_async</strong></dt>
<dd>Using Glusterfs libgfapi async interface to direct access to
Glusterfs volumes without having to go through FUSE. This ioengine
defines engine specific options.</dd>
<dt><strong>libhdfs</strong></dt>
<dd>Read and write through Hadoop (HDFS).  The <code class="file docutils literal"><span class="pre">filename</span></code> option
is used to specify host,port of the hdfs name-node to connect.  This
engine interprets offsets a little differently.  In HDFS, files once
created cannot be modified.  So random writes are not possible. To
imitate this, libhdfs engine expects bunch of small files to be
created over HDFS, and engine will randomly pick a file out of those
files based on the offset generated by fio backend. (see the example
job file to create such files, use <code class="docutils literal"><span class="pre">rw=write</span></code> option). Please
note, you might want to set necessary environment variables to work
with hdfs/libhdfs properly.  Each job uses its own connection to
HDFS.</dd>
<dt><strong>mtd</strong></dt>
<dd>Read, write and erase an MTD character device (e.g.,
<code class="file docutils literal"><span class="pre">/dev/mtd0</span></code>). Discards are treated as erases. Depending on the
underlying device type, the I/O may have to go in a certain pattern,
e.g., on NAND, writing sequentially to erase blocks and discarding
before overwriting. The writetrim mode works well for this
constraint.</dd>
<dt><strong>pmemblk</strong></dt>
<dd>Read and write using filesystem DAX to a file on a filesystem
mounted with DAX on a persistent memory device through the NVML
libpmemblk library.</dd>
<dt><strong>dev-dax</strong></dt>
<dd>Read and write using device DAX to a persistent memory device (e.g.,
/dev/dax0.0) through the NVML libpmem library.</dd>
<dt><strong>external</strong></dt>
<dd>Prefix to specify loading an external I/O engine object file. Append
the engine filename, e.g. <code class="docutils literal"><span class="pre">ioengine=external:/tmp/foo.o</span></code> to load
ioengine <code class="file docutils literal"><span class="pre">foo.o</span></code> in <code class="file docutils literal"><span class="pre">/tmp</span></code>.</dd>
</dl>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="i-o-engine-specific-parameters">
<h3>I/O engine specific parameters<a class="headerlink" href="#i-o-engine-specific-parameters" title="Permalink to this headline">¶</a></h3>
<p>In addition, there are some parameters which are only valid when a specific
ioengine is in use. These are used identically to normal parameters, with the
caveat that when used on the command line, they must come after the
<a class="reference internal" href="#cmdoption-arg-ioengine"><code class="xref std std-option docutils literal"><span class="pre">ioengine</span></code></a> that defines them is selected.</p>
<dl class="option">
<dt id="cmdoption-arg-userspace_reap">
<code class="descname">userspace_reap</code><code class="descclassname"> : [libaio]</code><a class="headerlink" href="#cmdoption-arg-userspace_reap" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally, with the libaio engine in use, fio will use the
<em class="manpage">io_getevents(2)</em> system call to reap newly returned events.  With
this flag turned on, the AIO ring will be read directly from user-space to
reap events. The reaping mode is only enabled when polling for a minimum of
0 events (e.g. when <a class="reference internal" href="#cmdoption-arg-iodepth_batch_complete"><code class="xref std std-option docutils literal"><span class="pre">iodepth_batch_complete</span></code></a> <cite>=0</cite>).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-hipri">
<code class="descname">hipri</code><code class="descclassname"> : [pvsync2]</code><a class="headerlink" href="#cmdoption-arg-hipri" title="Permalink to this definition">¶</a></dt>
<dd><p>Set RWF_HIPRI on I/O, indicating to the kernel that it&#8217;s of higher priority
than normal.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cpuload">
<code class="descname">cpuload</code><code class="descclassname">=int : [cpuio]</code><a class="headerlink" href="#cmdoption-arg-cpuload" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to use the specified percentage of CPU cycles.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cpuchunks">
<code class="descname">cpuchunks</code><code class="descclassname">=int : [cpuio]</code><a class="headerlink" href="#cmdoption-arg-cpuchunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the load into cycles of the given time. In microseconds.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-exit_on_io_done">
<code class="descname">exit_on_io_done</code><code class="descclassname">=bool : [cpuio]</code><a class="headerlink" href="#cmdoption-arg-exit_on_io_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect when I/O threads are done, then exit.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-hostname">
<code class="descname">hostname</code><code class="descclassname">=str : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-hostname" title="Permalink to this definition">¶</a></dt>
<dd><p>The host name or IP address to use for TCP or UDP based I/O.  If the job is
a TCP listener or UDP reader, the host name is not used and must be omitted
unless it is a valid UDP multicast address.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-namenode">
<code class="descname">namenode</code><code class="descclassname">=str : [libhdfs]</code><a class="headerlink" href="#cmdoption-arg-namenode" title="Permalink to this definition">¶</a></dt>
<dd><p>The host name or IP address of a HDFS cluster namenode to contact.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-port">
<code class="descname">port</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-port" title="Permalink to this definition">¶</a></dt>
<dd><p>[netsplice], [net]</p>
<blockquote>
<div>The TCP or UDP port to bind to or connect to. If this is used with
<a class="reference internal" href="#cmdoption-arg-numjobs"><code class="xref std std-option docutils literal"><span class="pre">numjobs</span></code></a> to spawn multiple instances of the same job type, then
this will be the starting port number since fio will use a range of
ports.</div></blockquote>
<p>[libhdfs]</p>
<blockquote>
<div>the listening port of the HFDS cluster namenode.</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-interface">
<code class="descname">interface</code><code class="descclassname">=str : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-interface" title="Permalink to this definition">¶</a></dt>
<dd><p>The IP address of the network interface used to send or receive UDP
multicast.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ttl">
<code class="descname">ttl</code><code class="descclassname">=int : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-ttl" title="Permalink to this definition">¶</a></dt>
<dd><p>Time-to-live value for outgoing UDP multicast packets. Default: 1.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-nodelay">
<code class="descname">nodelay</code><code class="descclassname">=bool : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-nodelay" title="Permalink to this definition">¶</a></dt>
<dd><p>Set TCP_NODELAY on TCP connections.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-protocol">
<code class="descname">protocol</code><code class="descclassname">=str : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-protocol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="option">
<dt id="cmdoption-arg-proto">
<code class="descname">proto</code><code class="descclassname">=str : [netsplice] [net]</code><a class="headerlink" href="#cmdoption-arg-proto" title="Permalink to this definition">¶</a></dt>
<dd><p>The network protocol to use. Accepted values are:</p>
<dl class="docutils">
<dt><strong>tcp</strong></dt>
<dd>Transmission control protocol.</dd>
<dt><strong>tcpv6</strong></dt>
<dd>Transmission control protocol V6.</dd>
<dt><strong>udp</strong></dt>
<dd>User datagram protocol.</dd>
<dt><strong>udpv6</strong></dt>
<dd>User datagram protocol V6.</dd>
<dt><strong>unix</strong></dt>
<dd>UNIX domain socket.</dd>
</dl>
<p>When the protocol is TCP or UDP, the port must also be given, as well as the
hostname if the job is a TCP listener or UDP reader. For unix sockets, the
normal filename option should be used and the port is invalid.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-listen">
<code class="descname">listen</code><code class="descclassname"> : [net]</code><a class="headerlink" href="#cmdoption-arg-listen" title="Permalink to this definition">¶</a></dt>
<dd><p>For TCP network connections, tell fio to listen for incoming connections
rather than initiating an outgoing connection. The <a class="reference internal" href="#cmdoption-arg-hostname"><code class="xref std std-option docutils literal"><span class="pre">hostname</span></code></a> must
be omitted if this option is used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-pingpong">
<code class="descname">pingpong</code><code class="descclassname"> : [net]</code><a class="headerlink" href="#cmdoption-arg-pingpong" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally a network writer will just continue writing data, and a network
reader will just consume packages. If <code class="docutils literal"><span class="pre">pingpong=1</span></code> is set, a writer will
send its normal payload to the reader, then wait for the reader to send the
same payload back. This allows fio to measure network latencies. The
submission and completion latencies then measure local time spent sending or
receiving, and the completion latency measures how long it took for the
other end to receive and send back.  For UDP multicast traffic
<code class="docutils literal"><span class="pre">pingpong=1</span></code> should only be set for a single reader when multiple readers
are listening to the same address.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-window_size">
<code class="descname">window_size</code><code class="descclassname"> : [net]</code><a class="headerlink" href="#cmdoption-arg-window_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the desired socket buffer size for the connection.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-mss">
<code class="descname">mss</code><code class="descclassname"> : [net]</code><a class="headerlink" href="#cmdoption-arg-mss" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the TCP maximum segment size (TCP_MAXSEG).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-donorname">
<code class="descname">donorname</code><code class="descclassname">=str : [e4defrag]</code><a class="headerlink" href="#cmdoption-arg-donorname" title="Permalink to this definition">¶</a></dt>
<dd><p>File will be used as a block donor(swap extents between files).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-inplace">
<code class="descname">inplace</code><code class="descclassname">=int : [e4defrag]</code><a class="headerlink" href="#cmdoption-arg-inplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure donor file blocks allocation strategy:</p>
<dl class="docutils">
<dt><strong>0</strong></dt>
<dd>Default. Preallocate donor&#8217;s file on init.</dd>
<dt><strong>1</strong></dt>
<dd>Allocate space immediately inside defragment event,     and free right
after event.</dd>
</dl>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-clustername">
<code class="descname">clustername</code><code class="descclassname">=str : [rbd]</code><a class="headerlink" href="#cmdoption-arg-clustername" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the name of the Ceph cluster.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rbdname">
<code class="descname">rbdname</code><code class="descclassname">=str : [rbd]</code><a class="headerlink" href="#cmdoption-arg-rbdname" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the name of the RBD.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-pool">
<code class="descname">pool</code><code class="descclassname">=str : [rbd]</code><a class="headerlink" href="#cmdoption-arg-pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the name of the Ceph pool containing RBD.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-clientname">
<code class="descname">clientname</code><code class="descclassname">=str : [rbd]</code><a class="headerlink" href="#cmdoption-arg-clientname" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the username (without the &#8216;client.&#8217; prefix) used to access the
Ceph cluster. If the <em>clustername</em> is specified, the <em>clientname</em> shall be
the full <em>type.id</em> string. If no type. prefix is given, fio will add
&#8216;client.&#8217; by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-skip_bad">
<code class="descname">skip_bad</code><code class="descclassname">=bool : [mtd]</code><a class="headerlink" href="#cmdoption-arg-skip_bad" title="Permalink to this definition">¶</a></dt>
<dd><p>Skip operations against known bad blocks.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-hdfsdirectory">
<code class="descname">hdfsdirectory</code><code class="descclassname"> : [libhdfs]</code><a class="headerlink" href="#cmdoption-arg-hdfsdirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>libhdfs will create chunk in this HDFS directory.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-chunk_size">
<code class="descname">chunk_size</code><code class="descclassname"> : [libhdfs]</code><a class="headerlink" href="#cmdoption-arg-chunk_size" title="Permalink to this definition">¶</a></dt>
<dd><p>the size of the chunk to use for each file.</p>
</dd></dl>

</div>
<div class="section" id="i-o-depth">
<h3>I/O depth<a class="headerlink" href="#i-o-depth" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-iodepth">
<code class="descname">iodepth</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of I/O units to keep in flight against the file.  Note that
increasing <em>iodepth</em> beyond 1 will not affect synchronous ioengines (except
for small degrees when <a class="reference internal" href="#cmdoption-arg-verify_async"><code class="xref std std-option docutils literal"><span class="pre">verify_async</span></code></a> is in use).  Even async
engines may impose OS restrictions causing the desired depth not to be
achieved.  This may happen on Linux when using libaio and not setting
<a class="reference internal" href="#cmdoption-arg-direct"><code class="xref std std-option docutils literal"><span class="pre">direct</span></code></a> =1, since buffered I/O is not async on that OS.  Keep an
eye on the I/O depth distribution in the fio output to verify that the
achieved depth is as expected. Default: 1.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth_batch_submit">
<span id="cmdoption-arg-iodepth_batch"></span><code class="descname">iodepth_batch_submit</code><code class="descclassname">=int</code><code class="descclassname">, </code><code class="descname">iodepth_batch</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth_batch_submit" title="Permalink to this definition">¶</a></dt>
<dd><p>This defines how many pieces of I/O to submit at once.  It defaults to 1
which means that we submit each I/O as soon as it is available, but can be
raised to submit bigger batches of I/O at the time. If it is set to 0 the
<a class="reference internal" href="#cmdoption-arg-iodepth"><code class="xref std std-option docutils literal"><span class="pre">iodepth</span></code></a> value will be used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth_batch_complete_min">
<span id="cmdoption-arg-iodepth_batch_complete"></span><code class="descname">iodepth_batch_complete_min</code><code class="descclassname">=int</code><code class="descclassname">, </code><code class="descname">iodepth_batch_complete</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth_batch_complete_min" title="Permalink to this definition">¶</a></dt>
<dd><p>This defines how many pieces of I/O to retrieve at once. It defaults to 1
which means that we&#8217;ll ask for a minimum of 1 I/O in the retrieval process
from the kernel. The I/O retrieval will go on until we hit the limit set by
<a class="reference internal" href="#cmdoption-arg-iodepth_low"><code class="xref std std-option docutils literal"><span class="pre">iodepth_low</span></code></a>. If this variable is set to 0, then fio will always
check for completed events before queuing more I/O. This helps reduce I/O
latency, at the cost of more retrieval system calls.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth_batch_complete_max">
<code class="descname">iodepth_batch_complete_max</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth_batch_complete_max" title="Permalink to this definition">¶</a></dt>
<dd><p>This defines maximum pieces of I/O to retrieve at once. This variable should
be used along with <a class="reference internal" href="#cmdoption-arg-iodepth_batch_complete_min"><code class="xref std std-option docutils literal"><span class="pre">iodepth_batch_complete_min</span></code></a> =int variable,
specifying the range of min and max amount of I/O which should be
retrieved. By default it is equal to <a class="reference internal" href="#cmdoption-arg-iodepth_batch_complete_min"><code class="xref std std-option docutils literal"><span class="pre">iodepth_batch_complete_min</span></code></a>
value.</p>
<p>Example #1:</p>
<div class="highlight-python"><div class="highlight"><pre>iodepth_batch_complete_min=1
iodepth_batch_complete_max=&lt;iodepth&gt;
</pre></div>
</div>
<p>which means that we will retrieve at least 1 I/O and up to the whole
submitted queue depth. If none of I/O has been completed yet, we will wait.</p>
<p>Example #2:</p>
<div class="highlight-python"><div class="highlight"><pre>iodepth_batch_complete_min=0
iodepth_batch_complete_max=&lt;iodepth&gt;
</pre></div>
</div>
<p>which means that we can retrieve up to the whole submitted queue depth, but
if none of I/O has been completed yet, we will NOT wait and immediately exit
the system call. In this example we simply do polling.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iodepth_low">
<code class="descname">iodepth_low</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iodepth_low" title="Permalink to this definition">¶</a></dt>
<dd><p>The low water mark indicating when to start filling the queue
again. Defaults to the same as <a class="reference internal" href="#cmdoption-arg-iodepth"><code class="xref std std-option docutils literal"><span class="pre">iodepth</span></code></a>, meaning that fio will
attempt to keep the queue full at all times.  If <a class="reference internal" href="#cmdoption-arg-iodepth"><code class="xref std std-option docutils literal"><span class="pre">iodepth</span></code></a> is set to
e.g. 16 and <em>iodepth_low</em> is set to 4, then after fio has filled the queue of
16 requests, it will let the depth drain down to 4 before starting to fill
it again.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-io_submit_mode">
<code class="descname">io_submit_mode</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-io_submit_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>This option controls how fio submits the I/O to the I/O engine. The default
is <cite>inline</cite>, which means that the fio job threads submit and reap I/O
directly. If set to <cite>offload</cite>, the job threads will offload I/O submission
to a dedicated pool of I/O threads. This requires some coordination and thus
has a bit of extra overhead, especially for lower queue depth I/O where it
can increase latencies. The benefit is that fio can manage submission rates
independently of the device completion rates. This avoids skewed latency
reporting if I/O gets back up on the device side (the coordinated omission
problem).</p>
</dd></dl>

</div>
<div class="section" id="i-o-rate">
<h3>I/O rate<a class="headerlink" href="#i-o-rate" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-thinktime">
<code class="descname">thinktime</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-thinktime" title="Permalink to this definition">¶</a></dt>
<dd><p>Stall the job for the specified period of time after an I/O has completed before issuing the
next. May be used to simulate processing being done by an application.
When the unit is omitted, the value is given in microseconds.  See
<a class="reference internal" href="#cmdoption-arg-thinktime_blocks"><code class="xref std std-option docutils literal"><span class="pre">thinktime_blocks</span></code></a> and <a class="reference internal" href="#cmdoption-arg-thinktime_spin"><code class="xref std std-option docutils literal"><span class="pre">thinktime_spin</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-thinktime_spin">
<code class="descname">thinktime_spin</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-thinktime_spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Only valid if <a class="reference internal" href="#cmdoption-arg-thinktime"><code class="xref std std-option docutils literal"><span class="pre">thinktime</span></code></a> is set - pretend to spend CPU time doing
something with the data received, before falling back to sleeping for the
rest of the period specified by <a class="reference internal" href="#cmdoption-arg-thinktime"><code class="xref std std-option docutils literal"><span class="pre">thinktime</span></code></a>.  When the unit is
omitted, the value is given in microseconds.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-thinktime_blocks">
<code class="descname">thinktime_blocks</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-thinktime_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Only valid if <a class="reference internal" href="#cmdoption-arg-thinktime"><code class="xref std std-option docutils literal"><span class="pre">thinktime</span></code></a> is set - control how many blocks to issue,
before waiting <cite>thinktime</cite> usecs. If not set, defaults to 1 which will make
fio wait <cite>thinktime</cite> usecs after every block. This effectively makes any
queue depth setting redundant, since no more than 1 I/O will be queued
before we have to complete it and do our thinktime. In other words, this
setting effectively caps the queue depth if the latter is larger.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate">
<code class="descname">rate</code><code class="descclassname">=int[,int][,int]</code><a class="headerlink" href="#cmdoption-arg-rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Cap the bandwidth used by this job. The number is in bytes/sec, the normal
suffix rules apply.  Comma-separated values may be specified for reads,
writes, and trims as described in <a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate_min">
<code class="descname">rate_min</code><code class="descclassname">=int[,int][,int]</code><a class="headerlink" href="#cmdoption-arg-rate_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell fio to do whatever it can to maintain at least this bandwidth. Failing
to meet this requirement will cause the job to exit.  Comma-separated values
may be specified for reads, writes, and trims as described in
<a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate_iops">
<code class="descname">rate_iops</code><code class="descclassname">=int[,int][,int]</code><a class="headerlink" href="#cmdoption-arg-rate_iops" title="Permalink to this definition">¶</a></dt>
<dd><p>Cap the bandwidth to this number of IOPS. Basically the same as
<a class="reference internal" href="#cmdoption-arg-rate"><code class="xref std std-option docutils literal"><span class="pre">rate</span></code></a>, just specified independently of bandwidth. If the job is
given a block size range instead of a fixed value, the smallest block size
is used as the metric.  Comma-separated values may be specified for reads,
writes, and trims as described in <a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate_iops_min">
<code class="descname">rate_iops_min</code><code class="descclassname">=int[,int][,int]</code><a class="headerlink" href="#cmdoption-arg-rate_iops_min" title="Permalink to this definition">¶</a></dt>
<dd><p>If fio doesn&#8217;t meet this rate of I/O, it will cause the job to exit.
Comma-separated values may be specified for reads, writes, and trims as
described in <a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate_process">
<code class="descname">rate_process</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-rate_process" title="Permalink to this definition">¶</a></dt>
<dd><p>This option controls how fio manages rated I/O submissions. The default is
<cite>linear</cite>, which submits I/O in a linear fashion with fixed delays between
I/Os that gets adjusted based on I/O completion rates. If this is set to
<cite>poisson</cite>, fio will submit I/O based on a more real world random request
flow, known as the Poisson process
(<a class="reference external" href="https://en.wikipedia.org/wiki/Poisson_point_process">https://en.wikipedia.org/wiki/Poisson_point_process</a>). The lambda will be
10^6 / IOPS for the given workload.</p>
</dd></dl>

</div>
<div class="section" id="i-o-latency">
<h3>I/O latency<a class="headerlink" href="#i-o-latency" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-latency_target">
<code class="descname">latency_target</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-latency_target" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will attempt to find the max performance point that the given
workload will run at while maintaining a latency below this target.  When
the unit is omitted, the value is given in microseconds.  See
<a class="reference internal" href="#cmdoption-arg-latency_window"><code class="xref std std-option docutils literal"><span class="pre">latency_window</span></code></a> and <a class="reference internal" href="#cmdoption-arg-latency_percentile"><code class="xref std std-option docutils literal"><span class="pre">latency_percentile</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-latency_window">
<code class="descname">latency_window</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-latency_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Used with <a class="reference internal" href="#cmdoption-arg-latency_target"><code class="xref std std-option docutils literal"><span class="pre">latency_target</span></code></a> to specify the sample window that the job
is run at varying queue depths to test the performance.  When the unit is
omitted, the value is given in microseconds.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-latency_percentile">
<code class="descname">latency_percentile</code><code class="descclassname">=float</code><a class="headerlink" href="#cmdoption-arg-latency_percentile" title="Permalink to this definition">¶</a></dt>
<dd><p>The percentage of I/Os that must fall within the criteria specified by
<a class="reference internal" href="#cmdoption-arg-latency_target"><code class="xref std std-option docutils literal"><span class="pre">latency_target</span></code></a> and <a class="reference internal" href="#cmdoption-arg-latency_window"><code class="xref std std-option docutils literal"><span class="pre">latency_window</span></code></a>. If not set, this
defaults to 100.0, meaning that all I/Os must be equal or below to the value
set by <a class="reference internal" href="#cmdoption-arg-latency_target"><code class="xref std std-option docutils literal"><span class="pre">latency_target</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-max_latency">
<code class="descname">max_latency</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-max_latency" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will exit the job with an ETIMEDOUT error if it exceeds this
maximum latency. When the unit is omitted, the value is given in
microseconds.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-rate_cycle">
<code class="descname">rate_cycle</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-rate_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Average bandwidth for <a class="reference internal" href="#cmdoption-arg-rate"><code class="xref std std-option docutils literal"><span class="pre">rate</span></code></a> and <a class="reference internal" href="#cmdoption-arg-rate_min"><code class="xref std std-option docutils literal"><span class="pre">rate_min</span></code></a> over this number
of milliseconds.</p>
</dd></dl>

</div>
<div class="section" id="i-o-replay">
<h3>I/O replay<a class="headerlink" href="#i-o-replay" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-write_iolog">
<code class="descname">write_iolog</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-write_iolog" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the issued I/O patterns to the specified file. See
<a class="reference internal" href="#cmdoption-arg-read_iolog"><code class="xref std std-option docutils literal"><span class="pre">read_iolog</span></code></a>.  Specify a separate file for each job, otherwise the
iologs will be interspersed and the file may be corrupt.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-read_iolog">
<code class="descname">read_iolog</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-read_iolog" title="Permalink to this definition">¶</a></dt>
<dd><p>Open an iolog with the specified file name and replay the I/O patterns it
contains. This can be used to store a workload and replay it sometime
later. The iolog given may also be a blktrace binary file, which allows fio
to replay a workload captured by <strong class="command">blktrace</strong>. See
<em class="manpage">blktrace(8)</em> for how to capture such logging data. For blktrace
replay, the file needs to be turned into a blkparse binary data file first
(<code class="docutils literal"><span class="pre">blkparse</span> <span class="pre">&lt;device&gt;</span> <span class="pre">-o</span> <span class="pre">/dev/null</span> <span class="pre">-d</span> <span class="pre">file_for_fio.bin</span></code>).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-replay_no_stall">
<code class="descname">replay_no_stall</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-replay_no_stall" title="Permalink to this definition">¶</a></dt>
<dd><p>When replaying I/O with <a class="reference internal" href="#cmdoption-arg-read_iolog"><code class="xref std std-option docutils literal"><span class="pre">read_iolog</span></code></a> the default behavior is to
attempt to respect the time stamps within the log and replay them with the
appropriate delay between IOPS. By setting this variable fio will not
respect the timestamps and attempt to replay them as fast as possible while
still respecting ordering. The result is the same I/O pattern to a given
device, but different timings.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-replay_redirect">
<code class="descname">replay_redirect</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-replay_redirect" title="Permalink to this definition">¶</a></dt>
<dd><p>While replaying I/O patterns using <a class="reference internal" href="#cmdoption-arg-read_iolog"><code class="xref std std-option docutils literal"><span class="pre">read_iolog</span></code></a> the default behavior
is to replay the IOPS onto the major/minor device that each IOP was recorded
from.  This is sometimes undesirable because on a different machine those
major/minor numbers can map to a different device.  Changing hardware on the
same system can also result in a different major/minor mapping.
<code class="docutils literal"><span class="pre">replay_redirect</span></code> causes all IOPS to be replayed onto the single specified
device regardless of the device it was recorded
from. i.e. <a class="reference internal" href="#cmdoption-arg-replay_redirect"><code class="xref std std-option docutils literal"><span class="pre">replay_redirect</span></code></a> = <code class="file docutils literal"><span class="pre">/dev/sdc</span></code> would cause all I/O
in the blktrace or iolog to be replayed onto <code class="file docutils literal"><span class="pre">/dev/sdc</span></code>.  This means
multiple devices will be replayed onto a single device, if the trace
contains multiple devices. If you want multiple devices to be replayed
concurrently to multiple redirected devices you must blkparse your trace
into separate traces and replay them with independent fio invocations.
Unfortunately this also breaks the strict time ordering between multiple
device accesses.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-replay_align">
<code class="descname">replay_align</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-replay_align" title="Permalink to this definition">¶</a></dt>
<dd><p>Force alignment of I/O offsets and lengths in a trace to this power of 2
value.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-replay_scale">
<code class="descname">replay_scale</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-replay_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale sector offsets down by this factor when replaying traces.</p>
</dd></dl>

</div>
<div class="section" id="threads-processes-and-job-synchronization">
<h3>Threads, processes and job synchronization<a class="headerlink" href="#threads-processes-and-job-synchronization" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-thread">
<code class="descname">thread</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-thread" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio defaults to forking jobs, however if this option is given, fio will use
POSIX Threads function <em class="manpage">pthread_create(3)</em> to create threads instead
of forking processes.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-wait_for">
<code class="descname">wait_for</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-wait_for" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the name of the already defined job to wait for. Single waitee
name only may be specified. If set, the job won&#8217;t be started until all
workers of the waitee job are done.</p>
<p><code class="docutils literal"><span class="pre">wait_for</span></code> operates on the job name basis, so there are a few
limitations. First, the waitee must be defined prior to the waiter job
(meaning no forward references). Second, if a job is being referenced as a
waitee, it must have a unique name (no duplicate waitees).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-nice">
<code class="descname">nice</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-nice" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the job with the given nice value. See man <em class="manpage">nice(2)</em>.</p>
<p>On Windows, values less than -15 set the process class to &#8220;High&#8221;; -1 through
-15 set &#8220;Above Normal&#8221;; 1 through 15 &#8220;Below Normal&#8221;; and above 15 &#8220;Idle&#8221;
priority class.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-prio">
<code class="descname">prio</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-prio" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the I/O priority value of this job. Linux limits us to a positive value
between 0 and 7, with 0 being the highest.  See man
<em class="manpage">ionice(1)</em>. Refer to an appropriate manpage for other operating
systems since meaning of priority may differ.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-prioclass">
<code class="descname">prioclass</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-prioclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the I/O priority class. See man <em class="manpage">ionice(1)</em>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cpumask">
<code class="descname">cpumask</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-cpumask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the CPU affinity of this job. The parameter given is a bitmask of
allowed CPU&#8217;s the job may run on. So if you want the allowed CPUs to be 1
and 5, you would pass the decimal value of (1 &lt;&lt; 1 | 1 &lt;&lt; 5), or 34. See man
<em class="manpage">sched_setaffinity(2)</em>. This may not work on all supported
operating systems or kernel versions. This option doesn&#8217;t work well for a
higher CPU count than what you can store in an integer mask, so it can only
control cpus 1-32. For boxes with larger CPU counts, use
<a class="reference internal" href="#cmdoption-arg-cpus_allowed"><code class="xref std std-option docutils literal"><span class="pre">cpus_allowed</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cpus_allowed">
<code class="descname">cpus_allowed</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-cpus_allowed" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the same options as <a class="reference internal" href="#cmdoption-arg-cpumask"><code class="xref std std-option docutils literal"><span class="pre">cpumask</span></code></a>, but it allows a text setting
of the permitted CPUs instead. So to use CPUs 1 and 5, you would specify
<code class="docutils literal"><span class="pre">cpus_allowed=1,5</span></code>. This options also allows a range of CPUs. Say you
wanted a binding to CPUs 1, 5, and 8-15, you would set
<code class="docutils literal"><span class="pre">cpus_allowed=1,5,8-15</span></code>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cpus_allowed_policy">
<code class="descname">cpus_allowed_policy</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-cpus_allowed_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the policy of how fio distributes the CPUs specified by
<a class="reference internal" href="#cmdoption-arg-cpus_allowed"><code class="xref std std-option docutils literal"><span class="pre">cpus_allowed</span></code></a> or cpumask. Two policies are supported:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>shared</strong></dt>
<dd>All jobs will share the CPU set specified.</dd>
<dt><strong>split</strong></dt>
<dd>Each job will get a unique CPU from the CPU set.</dd>
</dl>
</div></blockquote>
<p><strong>shared</strong> is the default behaviour, if the option isn&#8217;t specified. If
<strong>split</strong> is specified, then fio will will assign one cpu per job. If not
enough CPUs are given for the jobs listed, then fio will roundrobin the CPUs
in the set.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-numa_cpu_nodes">
<code class="descname">numa_cpu_nodes</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-numa_cpu_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this job running on specified NUMA nodes&#8217; CPUs. The arguments allow
comma delimited list of cpu numbers, A-B ranges, or <cite>all</cite>. Note, to enable
numa options support, fio must be built on a system with libnuma-dev(el)
installed.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-numa_mem_policy">
<code class="descname">numa_mem_policy</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-numa_mem_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this job&#8217;s memory policy and corresponding NUMA nodes. Format of the
arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;mode&gt;[:&lt;nodelist&gt;]
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">mode</span></code> is one of the following memory policy: <code class="docutils literal"><span class="pre">default</span></code>, <code class="docutils literal"><span class="pre">prefer</span></code>,
<code class="docutils literal"><span class="pre">bind</span></code>, <code class="docutils literal"><span class="pre">interleave</span></code>, <code class="docutils literal"><span class="pre">local</span></code> For <code class="docutils literal"><span class="pre">default</span></code> and <code class="docutils literal"><span class="pre">local</span></code> memory
policy, no node is needed to be specified.  For <code class="docutils literal"><span class="pre">prefer</span></code>, only one node is
allowed.  For <code class="docutils literal"><span class="pre">bind</span></code> and <code class="docutils literal"><span class="pre">interleave</span></code>, it allow comma delimited list of
numbers, A-B ranges, or <cite>all</cite>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cgroup">
<code class="descname">cgroup</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-cgroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Add job to this control group. If it doesn&#8217;t exist, it will be created. The
system must have a mounted cgroup blkio mount point for this to work. If
your system doesn&#8217;t have it mounted, you can do so with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c1"># mount -t cgroup -o blkio none /cgroup</span>
</pre></div>
</div>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cgroup_weight">
<code class="descname">cgroup_weight</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-cgroup_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the weight of the cgroup to this value. See the documentation that comes
with the kernel, allowed values are in the range of 100..1000.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-cgroup_nodelete">
<code class="descname">cgroup_nodelete</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-cgroup_nodelete" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally fio will delete the cgroups it has created after the job
completion. To override this behavior and to leave cgroups around after the
job completion, set <code class="docutils literal"><span class="pre">cgroup_nodelete=1</span></code>.  This can be useful if one wants
to inspect various cgroup files after job completion. Default: false.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-flow_id">
<code class="descname">flow_id</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-flow_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The ID of the flow. If not specified, it defaults to being a global
flow. See <a class="reference internal" href="#cmdoption-arg-flow"><code class="xref std std-option docutils literal"><span class="pre">flow</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-flow">
<code class="descname">flow</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Weight in token-based flow control. If this value is used, then there is a
&#8216;flow counter&#8217; which is used to regulate the proportion of activity between
two or more jobs. Fio attempts to keep this flow counter near zero. The
<code class="docutils literal"><span class="pre">flow</span></code> parameter stands for how much should be added or subtracted to the
flow counter on each iteration of the main I/O loop. That is, if one job has
<code class="docutils literal"><span class="pre">flow=8</span></code> and another job has <code class="docutils literal"><span class="pre">flow=-1</span></code>, then there will be a roughly 1:8
ratio in how much one runs vs the other.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-flow_watermark">
<code class="descname">flow_watermark</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-flow_watermark" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum value that the absolute value of the flow counter is allowed to
reach before the job must wait for a lower value of the counter.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-flow_sleep">
<code class="descname">flow_sleep</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-flow_sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>The period of time, in microseconds, to wait after the flow watermark has
been exceeded before retrying operations.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-stonewall">
<span id="cmdoption-arg-wait_for_previous"></span><code class="descname">stonewall</code><code class="descclassname"></code><code class="descclassname">, </code><code class="descname">wait_for_previous</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-stonewall" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for preceding jobs in the job file to exit, before starting this
one. Can be used to insert serialization points in the job file. A stone
wall also implies starting a new reporting group, see
<a class="reference internal" href="#cmdoption-arg-group_reporting"><code class="xref std std-option docutils literal"><span class="pre">group_reporting</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-exitall">
<code class="descname">exitall</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-exitall" title="Permalink to this definition">¶</a></dt>
<dd><p>When one job finishes, terminate the rest. The default is to wait for each
job to finish, sometimes that is not the desired action.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-exec_prerun">
<code class="descname">exec_prerun</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-exec_prerun" title="Permalink to this definition">¶</a></dt>
<dd><p>Before running this job, issue the command specified through
<em class="manpage">system(3)</em>. Output is redirected in a file called
<code class="file docutils literal"><span class="pre">jobname.prerun.txt</span></code>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-exec_postrun">
<code class="descname">exec_postrun</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-exec_postrun" title="Permalink to this definition">¶</a></dt>
<dd><p>After the job completes, issue the command specified though
<em class="manpage">system(3)</em>. Output is redirected in a file called
<code class="file docutils literal"><span class="pre">jobname.postrun.txt</span></code>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-uid">
<code class="descname">uid</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-uid" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of running as the invoking user, set the user ID to this value
before the thread/process does any work.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-gid">
<code class="descname">gid</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-gid" title="Permalink to this definition">¶</a></dt>
<dd><p>Set group ID, see <a class="reference internal" href="#cmdoption-arg-uid"><code class="xref std std-option docutils literal"><span class="pre">uid</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="verification">
<h3>Verification<a class="headerlink" href="#verification" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-verify_only">
<code class="descname">verify_only</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-verify_only" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not perform specified workload, only verify data still matches previous
invocation of this workload. This option allows one to check data multiple
times at a later date without overwriting it. This option makes sense only
for workloads that write data, and does not support workloads with the
<a class="reference internal" href="#cmdoption-arg-time_based"><code class="xref std std-option docutils literal"><span class="pre">time_based</span></code></a> option set.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-do_verify">
<code class="descname">do_verify</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-do_verify" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the verify phase after a write phase. Only valid if <a class="reference internal" href="#cmdoption-arg-verify"><code class="xref std std-option docutils literal"><span class="pre">verify</span></code></a> is
set. Default: true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify">
<code class="descname">verify</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-verify" title="Permalink to this definition">¶</a></dt>
<dd><p>If writing to a file, fio can verify the file contents after each iteration
of the job. Each verification method also implies verification of special
header, which is written to the beginning of each block. This header also
includes meta information, like offset of the block, block number, timestamp
when block was written, etc.  <a class="reference internal" href="#cmdoption-arg-verify"><code class="xref std std-option docutils literal"><span class="pre">verify</span></code></a> can be combined with
<a class="reference internal" href="#cmdoption-arg-verify_pattern"><code class="xref std std-option docutils literal"><span class="pre">verify_pattern</span></code></a> option.  The allowed values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>md5</strong></dt>
<dd>Use an md5 sum of the data area and store it in the header of
each block.</dd>
<dt><strong>crc64</strong></dt>
<dd>Use an experimental crc64 sum of the data area and store it in the
header of each block.</dd>
<dt><strong>crc32c</strong></dt>
<dd>Use a crc32c sum of the data area and store it in the header of each
block.</dd>
<dt><strong>crc32c-intel</strong></dt>
<dd>Use hardware assisted crc32c calculation provided on SSE4.2 enabled
processors. Falls back to regular software crc32c, if not supported
by the system.</dd>
<dt><strong>crc32</strong></dt>
<dd>Use a crc32 sum of the data area and store it in the header of each
block.</dd>
<dt><strong>crc16</strong></dt>
<dd>Use a crc16 sum of the data area and store it in the header of each
block.</dd>
<dt><strong>crc7</strong></dt>
<dd>Use a crc7 sum of the data area and store it in the header of each
block.</dd>
<dt><strong>xxhash</strong></dt>
<dd>Use xxhash as the checksum function. Generally the fastest software
checksum that fio supports.</dd>
<dt><strong>sha512</strong></dt>
<dd>Use sha512 as the checksum function.</dd>
<dt><strong>sha256</strong></dt>
<dd>Use sha256 as the checksum function.</dd>
<dt><strong>sha1</strong></dt>
<dd>Use optimized sha1 as the checksum function.</dd>
<dt><strong>sha3-224</strong></dt>
<dd>Use optimized sha3-224 as the checksum function.</dd>
<dt><strong>sha3-256</strong></dt>
<dd>Use optimized sha3-256 as the checksum function.</dd>
<dt><strong>sha3-384</strong></dt>
<dd>Use optimized sha3-384 as the checksum function.</dd>
<dt><strong>sha3-512</strong></dt>
<dd>Use optimized sha3-512 as the checksum function.</dd>
<dt><strong>meta</strong></dt>
<dd>This option is deprecated, since now meta information is included in
generic verification header and meta verification happens by
default. For detailed information see the description of the
<a class="reference internal" href="#cmdoption-arg-verify"><code class="xref std std-option docutils literal"><span class="pre">verify</span></code></a> setting. This option is kept because of
compatibility&#8217;s sake with old configurations. Do not use it.</dd>
<dt><strong>pattern</strong></dt>
<dd>Verify a strict pattern. Normally fio includes a header with some
basic information and checksumming, but if this option is set, only
the specific pattern set with <a class="reference internal" href="#cmdoption-arg-verify_pattern"><code class="xref std std-option docutils literal"><span class="pre">verify_pattern</span></code></a> is verified.</dd>
<dt><strong>null</strong></dt>
<dd>Only pretend to verify. Useful for testing internals with
<a class="reference internal" href="#cmdoption-arg-ioengine"><code class="xref std std-option docutils literal"><span class="pre">ioengine</span></code></a> <cite>=null</cite>, not for much else.</dd>
</dl>
</div></blockquote>
<p>This option can be used for repeated burn-in tests of a system to make sure
that the written data is also correctly read back. If the data direction
given is a read or random read, fio will assume that it should verify a
previously written file. If the data direction includes any form of write,
the verify will be of the newly written data.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verifysort">
<code class="descname">verifysort</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-verifysort" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, fio will sort written verify blocks when it deems it faster to read
them back in a sorted manner. This is often the case when overwriting an
existing file, since the blocks are already laid out in the file system. You
can ignore this option unless doing huge amounts of really fast I/O where
the red-black tree sorting CPU time becomes significant. Default: true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verifysort_nr">
<code class="descname">verifysort_nr</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verifysort_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-load and sort verify blocks for a read workload.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_offset">
<code class="descname">verify_offset</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verify_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the verification header with data somewhere else in the block before
writing. It is swapped back before verifying.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_interval">
<code class="descname">verify_interval</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verify_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the verification header at a finer granularity than the
<a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a>. It will be written for chunks the size of
<code class="docutils literal"><span class="pre">verify_interval</span></code>. <a class="reference internal" href="#cmdoption-arg-blocksize"><code class="xref std std-option docutils literal"><span class="pre">blocksize</span></code></a> should divide this evenly.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_pattern">
<code class="descname">verify_pattern</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-verify_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will fill the I/O buffers with this pattern. Fio defaults to
filling with totally random bytes, but sometimes it&#8217;s interesting to fill
with a known pattern for I/O verification purposes. Depending on the width
of the pattern, fio will fill 1/2/3/4 bytes of the buffer at the time(it can
be either a decimal or a hex number).  The <code class="docutils literal"><span class="pre">verify_pattern</span></code> if larger than
a 32-bit quantity has to be a hex number that starts with either &#8220;0x&#8221; or
&#8220;0X&#8221;. Use with <a class="reference internal" href="#cmdoption-arg-verify"><code class="xref std std-option docutils literal"><span class="pre">verify</span></code></a>. Also, <code class="docutils literal"><span class="pre">verify_pattern</span></code> supports %o
format, which means that for each block offset will be written and then
verified back, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre>verify_pattern=%o
</pre></div>
</div>
<p>Or use combination of everything:</p>
<div class="highlight-python"><div class="highlight"><pre>verify_pattern=0xff%o&quot;abcd&quot;-12
</pre></div>
</div>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_fatal">
<code class="descname">verify_fatal</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-verify_fatal" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally fio will keep checking the entire contents before quitting on a
block verification failure. If this option is set, fio will exit the job on
the first observed failure. Default: false.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_dump">
<code class="descname">verify_dump</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-verify_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, dump the contents of both the original data block and the data block
we read off disk to files. This allows later analysis to inspect just what
kind of data corruption occurred. Off by default.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_async">
<code class="descname">verify_async</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verify_async" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio will normally verify I/O inline from the submitting thread. This option
takes an integer describing how many async offload threads to create for I/O
verification instead, causing fio to offload the duty of verifying I/O
contents to one or more separate threads. If using this offload option, even
sync I/O engines can benefit from using an <a class="reference internal" href="#cmdoption-arg-iodepth"><code class="xref std std-option docutils literal"><span class="pre">iodepth</span></code></a> setting higher
than 1, as it allows them to have I/O in flight while verifies are running.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_async_cpus">
<code class="descname">verify_async_cpus</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-verify_async_cpus" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell fio to set the given CPU affinity on the async I/O verification
threads. See <a class="reference internal" href="#cmdoption-arg-cpus_allowed"><code class="xref std std-option docutils literal"><span class="pre">cpus_allowed</span></code></a> for the format used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_backlog">
<code class="descname">verify_backlog</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verify_backlog" title="Permalink to this definition">¶</a></dt>
<dd><p>Fio will normally verify the written contents of a job that utilizes verify
once that job has completed. In other words, everything is written then
everything is read back and verified. You may want to verify continually
instead for a variety of reasons. Fio stores the meta data associated with
an I/O block in memory, so for large verify workloads, quite a bit of memory
would be used up holding this meta data. If this option is enabled, fio will
write only N blocks before verifying these blocks.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_backlog_batch">
<code class="descname">verify_backlog_batch</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-verify_backlog_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Control how many blocks fio will verify if <a class="reference internal" href="#cmdoption-arg-verify_backlog"><code class="xref std std-option docutils literal"><span class="pre">verify_backlog</span></code></a> is
set. If not set, will default to the value of <a class="reference internal" href="#cmdoption-arg-verify_backlog"><code class="xref std std-option docutils literal"><span class="pre">verify_backlog</span></code></a>
(meaning the entire queue is read back and verified).  If
<code class="docutils literal"><span class="pre">verify_backlog_batch</span></code> is less than <a class="reference internal" href="#cmdoption-arg-verify_backlog"><code class="xref std std-option docutils literal"><span class="pre">verify_backlog</span></code></a> then not all
blocks will be verified, if <code class="docutils literal"><span class="pre">verify_backlog_batch</span></code> is larger than
<a class="reference internal" href="#cmdoption-arg-verify_backlog"><code class="xref std std-option docutils literal"><span class="pre">verify_backlog</span></code></a>, some blocks will be verified more than once.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_state_save">
<code class="descname">verify_state_save</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-verify_state_save" title="Permalink to this definition">¶</a></dt>
<dd><p>When a job exits during the write phase of a verify workload, save its
current state. This allows fio to replay up until that point, if the verify
state is loaded for the verify read phase. The format of the filename is,
roughly:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;type&gt;-&lt;jobname&gt;-&lt;jobindex&gt;-verify.state.
</pre></div>
</div>
<p>&lt;type&gt; is &#8220;local&#8221; for a local run, &#8220;sock&#8221; for a client/server socket
connection, and &#8220;ip&#8221; (192.168.0.1, for instance) for a networked
client/server connection.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-verify_state_load">
<code class="descname">verify_state_load</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-verify_state_load" title="Permalink to this definition">¶</a></dt>
<dd><p>If a verify termination trigger was used, fio stores the current write state
of each thread. This can be used at verification time so that fio knows how
far it should verify.  Without this information, fio will run a full
verification pass, according to the settings in the job file used.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-trim_percentage">
<code class="descname">trim_percentage</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-trim_percentage" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of verify blocks to discard/trim.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-trim_verify_zero">
<code class="descname">trim_verify_zero</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-trim_verify_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that trim/discarded blocks are returned as zeroes.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-trim_backlog">
<code class="descname">trim_backlog</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-trim_backlog" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that trim/discarded blocks are returned as zeroes.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-trim_backlog_batch">
<code class="descname">trim_backlog_batch</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-trim_backlog_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Trim this number of I/O blocks.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-experimental_verify">
<code class="descname">experimental_verify</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-experimental_verify" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable experimental verification.</p>
</dd></dl>

</div>
<div class="section" id="steady-state">
<h3>Steady state<a class="headerlink" href="#steady-state" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-steadystate">
<span id="cmdoption-arg-ss"></span><code class="descname">steadystate</code><code class="descclassname">=str:float</code><code class="descclassname">, </code><code class="descname">ss</code><code class="descclassname">=str:float</code><a class="headerlink" href="#cmdoption-arg-steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the criterion and limit for assessing steady state performance. The
first parameter designates the criterion whereas the second parameter sets
the threshold. When the criterion falls below the threshold for the
specified duration, the job will stop. For example, <cite>iops_slope:0.1%</cite> will
direct fio to terminate the job when the least squares regression slope
falls below 0.1% of the mean IOPS. If <a class="reference internal" href="#cmdoption-arg-group_reporting"><code class="xref std std-option docutils literal"><span class="pre">group_reporting</span></code></a> is enabled
this will apply to all jobs in the group. Below is the list of available
steady state assessment criteria. All assessments are carried out using only
data from the rolling collection window. Threshold limits can be expressed
as a fixed value or as a percentage of the mean in the collection window.</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>iops</strong></dt>
<dd>Collect IOPS data. Stop the job if all individual IOPS measurements
are within the specified limit of the mean IOPS (e.g., <code class="docutils literal"><span class="pre">iops:2</span></code>
means that all individual IOPS values must be within 2 of the mean,
whereas <code class="docutils literal"><span class="pre">iops:0.2%</span></code> means that all individual IOPS values must be
within 0.2% of the mean IOPS to terminate the job).</dd>
<dt><strong>iops_slope</strong></dt>
<dd>Collect IOPS data and calculate the least squares regression
slope. Stop the job if the slope falls below the specified limit.</dd>
<dt><strong>bw</strong></dt>
<dd>Collect bandwidth data. Stop the job if all individual bandwidth
measurements are within the specified limit of the mean bandwidth.</dd>
<dt><strong>bw_slope</strong></dt>
<dd>Collect bandwidth data and calculate the least squares regression
slope. Stop the job if the slope falls below the specified limit.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-steadystate_duration">
<span id="cmdoption-arg-ss_dur"></span><code class="descname">steadystate_duration</code><code class="descclassname">=time</code><code class="descclassname">, </code><code class="descname">ss_dur</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-steadystate_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>A rolling window of this duration will be used to judge whether steady state
has been reached. Data will be collected once per second. The default is 0
which disables steady state detection.  When the unit is omitted, the
value is given in seconds.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-steadystate_ramp_time">
<span id="cmdoption-arg-ss_ramp"></span><code class="descname">steadystate_ramp_time</code><code class="descclassname">=time</code><code class="descclassname">, </code><code class="descname">ss_ramp</code><code class="descclassname">=time</code><a class="headerlink" href="#cmdoption-arg-steadystate_ramp_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the job to run for the specified duration before beginning data
collection for checking the steady state job termination criterion. The
default is 0.  When the unit is omitted, the value is given in seconds.</p>
</dd></dl>

</div>
<div class="section" id="measurements-and-reporting">
<h3>Measurements and reporting<a class="headerlink" href="#measurements-and-reporting" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-per_job_logs">
<code class="descname">per_job_logs</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-per_job_logs" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, this generates bw/clat/iops log with per file private filenames. If
not set, jobs with identical names will share the log filename. Default:
true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-group_reporting">
<code class="descname">group_reporting</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-group_reporting" title="Permalink to this definition">¶</a></dt>
<dd><p>It may sometimes be interesting to display statistics for groups of jobs as
a whole instead of for each individual job.  This is especially true if
<a class="reference internal" href="#cmdoption-arg-numjobs"><code class="xref std std-option docutils literal"><span class="pre">numjobs</span></code></a> is used; looking at individual thread/process output
quickly becomes unwieldy.  To see the final report per-group instead of
per-job, use <a class="reference internal" href="#cmdoption-arg-group_reporting"><code class="xref std std-option docutils literal"><span class="pre">group_reporting</span></code></a>. Jobs in a file will be part of the
same reporting group, unless if separated by a <a class="reference internal" href="#cmdoption-arg-stonewall"><code class="xref std std-option docutils literal"><span class="pre">stonewall</span></code></a>, or by
using <a class="reference internal" href="#cmdoption-arg-new_group"><code class="xref std std-option docutils literal"><span class="pre">new_group</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-new_group">
<code class="descname">new_group</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-new_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Start a new reporting group. See: <a class="reference internal" href="#cmdoption-arg-group_reporting"><code class="xref std std-option docutils literal"><span class="pre">group_reporting</span></code></a>.  If not given,
all jobs in a file will be part of the same reporting group, unless
separated by a <a class="reference internal" href="#cmdoption-arg-stonewall"><code class="xref std std-option docutils literal"><span class="pre">stonewall</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-stats">
<code class="descname">stats</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-stats" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, fio collects and shows final output results for all jobs
that run. If this option is set to 0, then fio will ignore it in
the final stat output.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-write_bw_log">
<code class="descname">write_bw_log</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-write_bw_log" title="Permalink to this definition">¶</a></dt>
<dd><p>If given, write a bandwidth log for this job. Can be used to store data of
the bandwidth of the jobs in their lifetime. The included
<strong class="command">fio_generate_plots</strong> script uses <strong class="command">gnuplot</strong> to turn these
text files into nice graphs. See <a class="reference internal" href="#cmdoption-arg-write_lat_log"><code class="xref std std-option docutils literal"><span class="pre">write_lat_log</span></code></a> for behaviour of
given filename. For this option, the postfix is <code class="file docutils literal"><span class="pre">_bw.x.log</span></code>, where <cite>x</cite>
is the index of the job (<cite>1..N</cite>, where <cite>N</cite> is the number of jobs). If
<a class="reference internal" href="#cmdoption-arg-per_job_logs"><code class="xref std std-option docutils literal"><span class="pre">per_job_logs</span></code></a> is false, then the filename will not include the job
index.  See <a class="reference internal" href="#log-file-formats">Log File Formats</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-write_lat_log">
<code class="descname">write_lat_log</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-write_lat_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#cmdoption-arg-write_bw_log"><code class="xref std std-option docutils literal"><span class="pre">write_bw_log</span></code></a>, except that this option stores I/O
submission, completion, and total latencies instead. If no filename is given
with this option, the default filename of <code class="file docutils literal"><span class="pre">jobname_type.log</span></code> is
used. Even if the filename is given, fio will still append the type of
log. So if one specifies:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">write_lat_log</span><span class="o">=</span><span class="n">foo</span>
</pre></div>
</div>
<p>The actual log names will be <code class="file docutils literal"><span class="pre">foo_slat.x.log</span></code>, <code class="file docutils literal"><span class="pre">foo_clat.x.log</span></code>,
and <code class="file docutils literal"><span class="pre">foo_lat.x.log</span></code>, where <cite>x</cite> is the index of the job (1..N, where N
is the number of jobs). This helps <strong class="command">fio_generate_plot</strong> find the
logs automatically. If <a class="reference internal" href="#cmdoption-arg-per_job_logs"><code class="xref std std-option docutils literal"><span class="pre">per_job_logs</span></code></a> is false, then the filename
will not include the job index.  See <a class="reference internal" href="#log-file-formats">Log File Formats</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-write_hist_log">
<code class="descname">write_hist_log</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-write_hist_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#cmdoption-arg-write_lat_log"><code class="xref std std-option docutils literal"><span class="pre">write_lat_log</span></code></a>, but writes I/O completion latency
histograms. If no filename is given with this option, the default filename
of <code class="file docutils literal"><span class="pre">jobname_clat_hist.x.log</span></code> is used, where <cite>x</cite> is the index of the
job (1..N, where <cite>N</cite> is the number of jobs). Even if the filename is given,
fio will still append the type of log.  If <a class="reference internal" href="#cmdoption-arg-per_job_logs"><code class="xref std std-option docutils literal"><span class="pre">per_job_logs</span></code></a> is false,
then the filename will not include the job index. See <a class="reference internal" href="#log-file-formats">Log File Formats</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-write_iops_log">
<code class="descname">write_iops_log</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-write_iops_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#cmdoption-arg-write_bw_log"><code class="xref std std-option docutils literal"><span class="pre">write_bw_log</span></code></a>, but writes IOPS. If no filename is given
with this option, the default filename of <code class="file docutils literal"><span class="pre">jobname_type.x.log</span></code> is
used,where <cite>x</cite> is the index of the job (1..N, where <cite>N</cite> is the number of
jobs). Even if the filename is given, fio will still append the type of
log. If <a class="reference internal" href="#cmdoption-arg-per_job_logs"><code class="xref std std-option docutils literal"><span class="pre">per_job_logs</span></code></a> is false, then the filename will not include
the job index. See <a class="reference internal" href="#log-file-formats">Log File Formats</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_avg_msec">
<code class="descname">log_avg_msec</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-log_avg_msec" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, fio will log an entry in the iops, latency, or bw log for every
I/O that completes. When writing to the disk log, that can quickly grow to a
very large size. Setting this option makes fio average the each log entry
over the specified period of time, reducing the resolution of the log.  See
<a class="reference internal" href="#cmdoption-arg-log_max_value"><code class="xref std std-option docutils literal"><span class="pre">log_max_value</span></code></a> as well. Defaults to 0, logging all entries.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_hist_msec">
<code class="descname">log_hist_msec</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-log_hist_msec" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#cmdoption-arg-log_avg_msec"><code class="xref std std-option docutils literal"><span class="pre">log_avg_msec</span></code></a>, but logs entries for completion latency
histograms. Computing latency percentiles from averages of intervals using
<a class="reference internal" href="#cmdoption-arg-log_avg_msec"><code class="xref std std-option docutils literal"><span class="pre">log_avg_msec</span></code></a> is inaccurate. Setting this option makes fio log
histogram entries over the specified period of time, reducing log sizes for
high IOPS devices while retaining percentile accuracy.  See
<a class="reference internal" href="#cmdoption-arg-log_hist_coarseness"><code class="xref std std-option docutils literal"><span class="pre">log_hist_coarseness</span></code></a> as well. Defaults to 0, meaning histogram
logging is disabled.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_hist_coarseness">
<code class="descname">log_hist_coarseness</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-log_hist_coarseness" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer ranging from 0 to 6, defining the coarseness of the resolution of
the histogram logs enabled with <a class="reference internal" href="#cmdoption-arg-log_hist_msec"><code class="xref std std-option docutils literal"><span class="pre">log_hist_msec</span></code></a>. For each increment
in coarseness, fio outputs half as many bins. Defaults to 0, for which
histogram logs contain 1216 latency bins. See <a class="reference internal" href="#log-file-formats">Log File Formats</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_max_value">
<code class="descname">log_max_value</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-log_max_value" title="Permalink to this definition">¶</a></dt>
<dd><p>If <a class="reference internal" href="#cmdoption-arg-log_avg_msec"><code class="xref std std-option docutils literal"><span class="pre">log_avg_msec</span></code></a> is set, fio logs the average over that window. If
you instead want to log the maximum value, set this option to 1. Defaults to
0, meaning that averaged values are logged.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_offset">
<code class="descname">log_offset</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-log_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is set, the iolog options will include the byte offset for the I/O
entry as well as the other data values.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_compression">
<code class="descname">log_compression</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-log_compression" title="Permalink to this definition">¶</a></dt>
<dd><p>If this is set, fio will compress the I/O logs as it goes, to keep the
memory footprint lower. When a log reaches the specified size, that chunk is
removed and compressed in the background. Given that I/O logs are fairly
highly compressible, this yields a nice memory savings for longer runs. The
downside is that the compression will consume some background CPU cycles, so
it may impact the run. This, however, is also true if the logging ends up
consuming most of the system memory.  So pick your poison. The I/O logs are
saved normally at the end of a run, by decompressing the chunks and storing
them in the specified log file. This feature depends on the availability of
zlib.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_compression_cpus">
<code class="descname">log_compression_cpus</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-log_compression_cpus" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the set of CPUs that are allowed to handle online log compression for
the I/O jobs. This can provide better isolation between performance
sensitive jobs, and background compression work.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_store_compressed">
<code class="descname">log_store_compressed</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-log_store_compressed" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will store the log files in a compressed format. They can be
decompressed with fio, using the <a class="reference internal" href="#cmdoption--inflate-log"><code class="xref std std-option docutils literal"><span class="pre">--inflate-log</span></code></a> command line
parameter. The files will be stored with a <code class="file docutils literal"><span class="pre">.fz</span></code> suffix.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-log_unix_epoch">
<code class="descname">log_unix_epoch</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-log_unix_epoch" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, fio will log Unix timestamps to the log files produced by enabling
write_type_log for each log type, instead of the default zero-based
timestamps.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-block_error_percentiles">
<code class="descname">block_error_percentiles</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-block_error_percentiles" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, record errors in trim block-sized units from writes and trims and
output a histogram of how many trims it took to get to errors, and what kind
of error was encountered.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-bwavgtime">
<code class="descname">bwavgtime</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-bwavgtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Average the calculated bandwidth over the given time. Value is specified in
milliseconds. If the job also does bandwidth logging through
<a class="reference internal" href="#cmdoption-arg-write_bw_log"><code class="xref std std-option docutils literal"><span class="pre">write_bw_log</span></code></a>, then the minimum of this option and
<a class="reference internal" href="#cmdoption-arg-log_avg_msec"><code class="xref std std-option docutils literal"><span class="pre">log_avg_msec</span></code></a> will be used.  Default: 500ms.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-iopsavgtime">
<code class="descname">iopsavgtime</code><code class="descclassname">=int</code><a class="headerlink" href="#cmdoption-arg-iopsavgtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Average the calculated IOPS over the given time. Value is specified in
milliseconds. If the job also does IOPS logging through
<a class="reference internal" href="#cmdoption-arg-write_iops_log"><code class="xref std std-option docutils literal"><span class="pre">write_iops_log</span></code></a>, then the minimum of this option and
<a class="reference internal" href="#cmdoption-arg-log_avg_msec"><code class="xref std std-option docutils literal"><span class="pre">log_avg_msec</span></code></a> will be used.  Default: 500ms.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-disk_util">
<code class="descname">disk_util</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-disk_util" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate disk utilization statistics, if the platform supports it.
Default: true.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-disable_lat">
<code class="descname">disable_lat</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-disable_lat" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable measurements of total latency numbers. Useful only for cutting back
the number of calls to <em class="manpage">gettimeofday(2)</em>, as that does impact
performance at really high IOPS rates.  Note that to really get rid of a
large amount of these calls, this option must be used with
<a class="reference internal" href="#cmdoption-arg-disable_slat"><code class="xref std std-option docutils literal"><span class="pre">disable_slat</span></code></a> and <a class="reference internal" href="#cmdoption-arg-disable_bw_measurement"><code class="xref std std-option docutils literal"><span class="pre">disable_bw_measurement</span></code></a> as well.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-disable_clat">
<code class="descname">disable_clat</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-disable_clat" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable measurements of completion latency numbers. See
<a class="reference internal" href="#cmdoption-arg-disable_lat"><code class="xref std std-option docutils literal"><span class="pre">disable_lat</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-disable_slat">
<code class="descname">disable_slat</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-disable_slat" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable measurements of submission latency numbers. See
<a class="reference internal" href="#cmdoption-arg-disable_slat"><code class="xref std std-option docutils literal"><span class="pre">disable_slat</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-disable_bw_measurement">
<span id="cmdoption-arg-disable_bw"></span><code class="descname">disable_bw_measurement</code><code class="descclassname">=bool</code><code class="descclassname">, </code><code class="descname">disable_bw</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-disable_bw_measurement" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable measurements of throughput/bandwidth numbers. See
<a class="reference internal" href="#cmdoption-arg-disable_lat"><code class="xref std std-option docutils literal"><span class="pre">disable_lat</span></code></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-clat_percentiles">
<code class="descname">clat_percentiles</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-clat_percentiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the reporting of percentiles of completion latencies.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-percentile_list">
<code class="descname">percentile_list</code><code class="descclassname">=float_list</code><a class="headerlink" href="#cmdoption-arg-percentile_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite the default list of percentiles for completion latencies and the
block error histogram.  Each number is a floating number in the range
(0,100], and the maximum length of the list is 20. Use <code class="docutils literal"><span class="pre">:</span></code> to separate the
numbers, and list the numbers in ascending order. For example,
<code class="docutils literal"><span class="pre">--percentile_list=99.5:99.9</span></code> will cause fio to report the values of
completion latency below which 99.5% and 99.9% of the observed latencies
fell, respectively.</p>
</dd></dl>

</div>
<div class="section" id="error-handling">
<h3>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt id="cmdoption-arg-exitall_on_error">
<code class="descname">exitall_on_error</code><code class="descclassname"></code><a class="headerlink" href="#cmdoption-arg-exitall_on_error" title="Permalink to this definition">¶</a></dt>
<dd><p>When one job finishes in error, terminate the rest. The default is to wait
for each job to finish.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-continue_on_error">
<code class="descname">continue_on_error</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-continue_on_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Normally fio will exit the job on the first observed failure. If this option
is set, fio will continue the job when there is a &#8216;non-fatal error&#8217; (EIO or
EILSEQ) until the runtime is exceeded or the I/O size specified is
completed. If this option is used, there are two more stats that are
appended, the total error count and the first error. The error field given
in the stats is the first error that was hit during the run.</p>
<p>The allowed values are:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>none</strong></dt>
<dd>Exit on any I/O or verify errors.</dd>
<dt><strong>read</strong></dt>
<dd>Continue on read errors, exit on all others.</dd>
<dt><strong>write</strong></dt>
<dd>Continue on write errors, exit on all others.</dd>
<dt><strong>io</strong></dt>
<dd>Continue on any I/O error, exit on all others.</dd>
<dt><strong>verify</strong></dt>
<dd>Continue on verify errors, exit on all others.</dd>
<dt><strong>all</strong></dt>
<dd>Continue on all errors.</dd>
<dt><strong>0</strong></dt>
<dd>Backward-compatible alias for &#8216;none&#8217;.</dd>
<dt><strong>1</strong></dt>
<dd>Backward-compatible alias for &#8216;all&#8217;.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-ignore_error">
<code class="descname">ignore_error</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-ignore_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Sometimes you want to ignore some errors during test in that case you can
specify error list for each error type.
<code class="docutils literal"><span class="pre">ignore_error=READ_ERR_LIST,WRITE_ERR_LIST,VERIFY_ERR_LIST</span></code> errors for
given error type is separated with &#8216;:&#8217;. Error may be symbol (&#8216;ENOSPC&#8217;,
&#8216;ENOMEM&#8217;) or integer.  Example:</p>
<div class="highlight-python"><div class="highlight"><pre>ignore_error=EAGAIN,ENOSPC:122
</pre></div>
</div>
<p>This option will ignore EAGAIN from READ, and ENOSPC and 122(EDQUOT) from
WRITE.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-arg-error_dump">
<code class="descname">error_dump</code><code class="descclassname">=bool</code><a class="headerlink" href="#cmdoption-arg-error_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>If set dump every error even if it is non fatal, true by default. If
disabled only fatal error will be dumped.</p>
</dd></dl>

</div>
</div>
<div class="section" id="running-predefined-workloads">
<h2>Running predefined workloads<a class="headerlink" href="#running-predefined-workloads" title="Permalink to this headline">¶</a></h2>
<p>Fio includes predefined profiles that mimic the I/O workloads generated by
other tools.</p>
<dl class="option">
<dt id="cmdoption-arg-profile">
<code class="descname">profile</code><code class="descclassname">=str</code><a class="headerlink" href="#cmdoption-arg-profile" title="Permalink to this definition">¶</a></dt>
<dd><p>The predefined workload to run.  Current profiles are:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>tiobench</strong></dt>
<dd>Threaded I/O bench (tiotest/tiobench) like workload.</dd>
<dt><strong>act</strong></dt>
<dd>Aerospike Certification Tool (ACT) like workload.</dd>
</dl>
</div></blockquote>
</dd></dl>

<p>To view a profile&#8217;s additional options use <a class="reference internal" href="#cmdoption--cmdhelp"><code class="xref std std-option docutils literal"><span class="pre">--cmdhelp</span></code></a> after specifying
the profile.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre>$ fio --profile=act --cmdhelp
</pre></div>
</div>
<div class="section" id="act-profile-options">
<h3>Act profile options<a class="headerlink" href="#act-profile-options" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt>
<code class="descname">device-names</code><code class="descclassname">=str</code></dt>
<dd><p>Devices to use.</p>
</dd></dl>

<dl class="option">
<dt>
<code class="descname">load</code><code class="descclassname">=int</code></dt>
<dd><p>ACT load multiplier.  Default: 1.</p>
</dd></dl>

<dl class="option">
<dt>
<code class="descname">test-duration</code><code class="descclassname">=time</code></dt>
<dd><p>How long the entire test takes to run.  Default: 24h.</p>
</dd></dl>

<dl class="option">
<dt>
<code class="descname">threads-per-queue</code><code class="descclassname">=int</code></dt>
<dd><p>Number of read IO threads per device.  Default: 8.</p>
</dd></dl>

<dl class="option">
<dt>
<code class="descname">read-req-num-512-blocks</code><code class="descclassname">=int</code></dt>
<dd><p>Number of 512B blocks to read at the time.  Default: 3.</p>
</dd></dl>

<dl class="option">
<dt>
<code class="descname">large-block-op-kbytes</code><code class="descclassname">=int</code></dt>
<dd><p>Size of large block ops in KiB (writes).  Default: 131072.</p>
</dd></dl>

<dl class="option">
<dt>
<code class="descname">prep</code><code class="descclassname"></code></dt>
<dd><p>Set to run ACT prep phase.</p>
</dd></dl>

</div>
<div class="section" id="tiobench-profile-options">
<h3>Tiobench profile options<a class="headerlink" href="#tiobench-profile-options" title="Permalink to this headline">¶</a></h3>
<dl class="option">
<dt>
<code class="descname">size</code><code class="descclassname">=str</code></dt>
<dd><p>Size in MiB</p>
</dd></dl>

<dl class="option">
<dt>
<code class="descname">block</code><code class="descclassname">=int</code></dt>
<dd><p>Block size in bytes.  Default: 4096.</p>
</dd></dl>

<dl class="option">
<dt>
<code class="descname">numruns</code><code class="descclassname">=int</code></dt>
<dd><p>Number of runs.</p>
</dd></dl>

<dl class="option">
<dt>
<code class="descname">dir</code><code class="descclassname">=str</code></dt>
<dd><p>Test directory.</p>
</dd></dl>

<dl class="option">
<dt>
<code class="descname">threads</code><code class="descclassname">=int</code></dt>
<dd><p>Number of threads.</p>
</dd></dl>

</div>
</div>
<div class="section" id="interpreting-the-output">
<h2>Interpreting the output<a class="headerlink" href="#interpreting-the-output" title="Permalink to this headline">¶</a></h2>
<p>Fio spits out a lot of output. While running, fio will display the status of the
jobs created. An example of that would be:</p>
<div class="highlight-python"><div class="highlight"><pre>Jobs: 1 (f=1): [_(1),M(1)][24.8%][r=20.5MiB/s,w=23.5MiB/s][r=82,w=94 IOPS][eta 01m:31s]
</pre></div>
</div>
<p>The characters inside the square brackets denote the current status of each
thread. The possible values (in typical life cycle order) are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="7%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Idle</th>
<th class="head">Run</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>P</td>
<td>&nbsp;</td>
<td>Thread setup, but not started.</td>
</tr>
<tr class="row-odd"><td>C</td>
<td>&nbsp;</td>
<td>Thread created.</td>
</tr>
<tr class="row-even"><td>I</td>
<td>&nbsp;</td>
<td>Thread initialized, waiting or generating necessary data.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>p</td>
<td>Thread running pre-reading file(s).</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>R</td>
<td>Running, doing sequential reads.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>r</td>
<td>Running, doing random reads.</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>W</td>
<td>Running, doing sequential writes.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>w</td>
<td>Running, doing random writes.</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>M</td>
<td>Running, doing mixed sequential reads/writes.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>m</td>
<td>Running, doing mixed random reads/writes.</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>F</td>
<td>Running, currently waiting for <em class="manpage">fsync(2)</em></td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>V</td>
<td>Running, doing verification of written data.</td>
</tr>
<tr class="row-even"><td>E</td>
<td>&nbsp;</td>
<td>Thread exited, not reaped by main thread yet.</td>
</tr>
<tr class="row-odd"><td>_</td>
<td>&nbsp;</td>
<td>Thread reaped, or</td>
</tr>
<tr class="row-even"><td>X</td>
<td>&nbsp;</td>
<td>Thread reaped, exited with an error.</td>
</tr>
<tr class="row-odd"><td>K</td>
<td>&nbsp;</td>
<td>Thread reaped, exited due to signal.</td>
</tr>
</tbody>
</table>
<p>Fio will condense the thread string as not to take up more space on the command
line as is needed. For instance, if you have 10 readers and 10 writers running,
the output would look like this:</p>
<div class="highlight-python"><div class="highlight"><pre>Jobs: 20 (f=20): [R(10),W(10)][4.0%][r=20.5MiB/s,w=23.5MiB/s][r=82,w=94 IOPS][eta 57m:36s]
</pre></div>
</div>
<p>Fio will still maintain the ordering, though. So the above means that jobs 1..10
are readers, and 11..20 are writers.</p>
<p>The other values are fairly self explanatory &#8211; number of threads currently
running and doing I/O, the number of currently open files (f=), the rate of I/O
since last check (read speed listed first, then write speed and optionally trim
speed), and the estimated completion percentage and time for the current
running group. It&#8217;s impossible to estimate runtime of the following groups (if
any). Note that the string is displayed in order, so it&#8217;s possible to tell which
of the jobs are currently doing what. The first character is the first job
defined in the job file, and so forth.</p>
<p>When fio is done (or interrupted by <code class="kbd docutils literal"><span class="pre">ctrl-c</span></code>), it will show the data for
each thread, group of threads, and disks in that order. For each data direction,
the output looks like:</p>
<div class="highlight-python"><div class="highlight"><pre>Client1 (g=0): err= 0:
  write: io=    32MiB, bw=   666KiB/s, iops=89 , runt= 50320msec
    slat (msec): min=    0, max=  136, avg= 0.03, stdev= 1.92
    clat (msec): min=    0, max=  631, avg=48.50, stdev=86.82
    bw (KiB/s) : min=    0, max= 1196, per=51.00%, avg=664.02, stdev=681.68
  cpu        : usr=1.49%, sys=0.25%, ctx=7969, majf=0, minf=17
  IO depths    : 1=0.1%, 2=0.3%, 4=0.5%, 8=99.0%, 16=0.0%, 32=0.0%, &gt;32=0.0%
     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%
     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%
     issued r/w: total=0/32768, short=0/0
     lat (msec): 2=1.6%, 4=0.0%, 10=3.2%, 20=12.8%, 50=38.4%, 100=24.8%,
     lat (msec): 250=15.2%, 500=0.0%, 750=0.0%, 1000=0.0%, &gt;=2048=0.0%
</pre></div>
</div>
<p>The client number is printed, along with the group id and error of that
thread. Below is the I/O statistics, here for writes. In the order listed, they
denote:</p>
<dl class="docutils">
<dt><strong>io</strong></dt>
<dd>Number of megabytes I/O performed.</dd>
<dt><strong>bw</strong></dt>
<dd>Average bandwidth rate.</dd>
<dt><strong>iops</strong></dt>
<dd>Average I/Os performed per second.</dd>
<dt><strong>runt</strong></dt>
<dd>The runtime of that thread.</dd>
<dt><strong>slat</strong></dt>
<dd>Submission latency (avg being the average, stdev being the standard
deviation). This is the time it took to submit the I/O. For sync I/O,
the slat is really the completion latency, since queue/complete is one
operation there. This value can be in milliseconds or microseconds, fio
will choose the most appropriate base and print that. In the example
above, milliseconds is the best scale. Note: in <a class="reference internal" href="#cmdoption--minimal"><code class="xref std std-option docutils literal"><span class="pre">--minimal</span></code></a> mode
latencies are always expressed in microseconds.</dd>
<dt><strong>clat</strong></dt>
<dd>Completion latency. Same names as slat, this denotes the time from
submission to completion of the I/O pieces. For sync I/O, clat will
usually be equal (or very close) to 0, as the time from submit to
complete is basically just CPU time (I/O has already been done, see slat
explanation).</dd>
<dt><strong>bw</strong></dt>
<dd>Bandwidth. Same names as the xlat stats, but also includes an
approximate percentage of total aggregate bandwidth this thread received
in this group. This last value is only really useful if the threads in
this group are on the same disk, since they are then competing for disk
access.</dd>
<dt><strong>cpu</strong></dt>
<dd>CPU usage. User and system time, along with the number of context
switches this thread went through, usage of system and user time, and
finally the number of major and minor page faults. The CPU utilization
numbers are averages for the jobs in that reporting group, while the
context and fault counters are summed.</dd>
<dt><strong>IO depths</strong></dt>
<dd>The distribution of I/O depths over the job life time. The numbers are
divided into powers of 2, so for example the 16= entries includes depths
up to that value but higher than the previous entry. In other words, it
covers the range from 16 to 31.</dd>
<dt><strong>IO submit</strong></dt>
<dd>How many pieces of I/O were submitting in a single submit call. Each
entry denotes that amount and below, until the previous entry &#8211; e.g.,
8=100% mean that we submitted anywhere in between 5-8 I/Os per submit
call.</dd>
<dt><strong>IO complete</strong></dt>
<dd>Like the above submit number, but for completions instead.</dd>
<dt><strong>IO issued</strong></dt>
<dd>The number of read/write requests issued, and how many of them were
short.</dd>
<dt><strong>IO latencies</strong></dt>
<dd>The distribution of I/O completion latencies. This is the time from when
I/O leaves fio and when it gets completed.  The numbers follow the same
pattern as the I/O depths, meaning that 2=1.6% means that 1.6% of the
I/O completed within 2 msecs, 20=12.8% means that 12.8% of the I/O took
more than 10 msecs, but less than (or equal to) 20 msecs.</dd>
</dl>
<p>After each client has been listed, the group statistics are printed. They
will look like this:</p>
<div class="highlight-python"><div class="highlight"><pre>Run status group 0 (all jobs):
   READ: io=64MB, aggrb=22178, minb=11355, maxb=11814, mint=2840msec, maxt=2955msec
  WRITE: io=64MB, aggrb=1302, minb=666, maxb=669, mint=50093msec, maxt=50320msec
</pre></div>
</div>
<p>For each data direction, it prints:</p>
<dl class="docutils">
<dt><strong>io</strong></dt>
<dd>Number of megabytes I/O performed.</dd>
<dt><strong>aggrb</strong></dt>
<dd>Aggregate bandwidth of threads in this group.</dd>
<dt><strong>minb</strong></dt>
<dd>The minimum average bandwidth a thread saw.</dd>
<dt><strong>maxb</strong></dt>
<dd>The maximum average bandwidth a thread saw.</dd>
<dt><strong>mint</strong></dt>
<dd>The smallest runtime of the threads in that group.</dd>
<dt><strong>maxt</strong></dt>
<dd>The longest runtime of the threads in that group.</dd>
</dl>
<p>And finally, the disk statistics are printed. They will look like this:</p>
<div class="highlight-python"><div class="highlight"><pre>Disk stats (read/write):
  sda: ios=16398/16511, merge=30/162, ticks=6853/819634, in_queue=826487, util=100.00%
</pre></div>
</div>
<p>Each value is printed for both reads and writes, with reads first. The
numbers denote:</p>
<dl class="docutils">
<dt><strong>ios</strong></dt>
<dd>Number of I/Os performed by all groups.</dd>
<dt><strong>merge</strong></dt>
<dd>Number of merges I/O the I/O scheduler.</dd>
<dt><strong>ticks</strong></dt>
<dd>Number of ticks we kept the disk busy.</dd>
<dt><strong>io_queue</strong></dt>
<dd>Total time spent in the disk queue.</dd>
<dt><strong>util</strong></dt>
<dd>The disk utilization. A value of 100% means we kept the disk
busy constantly, 50% would be a disk idling half of the time.</dd>
</dl>
<p>It is also possible to get fio to dump the current output while it is running,
without terminating the job. To do that, send fio the <strong>USR1</strong> signal.  You can
also get regularly timed dumps by using the <a class="reference internal" href="#cmdoption--status-interval"><code class="xref std std-option docutils literal"><span class="pre">--status-interval</span></code></a>
parameter, or by creating a file in <code class="file docutils literal"><span class="pre">/tmp</span></code> named
<code class="file docutils literal"><span class="pre">fio-dump-status</span></code>. If fio sees this file, it will unlink it and dump the
current output status.</p>
</div>
<div class="section" id="terse-output">
<h2>Terse output<a class="headerlink" href="#terse-output" title="Permalink to this headline">¶</a></h2>
<p>For scripted usage where you typically want to generate tables or graphs of the
results, fio can output the results in a semicolon separated format.  The format
is one long line of values, such as:</p>
<div class="highlight-python"><div class="highlight"><pre>2;card0;0;0;7139336;121836;60004;1;10109;27.932460;116.933948;220;126861;3495.446807;1085.368601;226;126864;3523.635629;1089.012448;24063;99944;50.275485%;59818.274627;5540.657370;7155060;122104;60004;1;8338;29.086342;117.839068;388;128077;5032.488518;1234.785715;391;128085;5061.839412;1236.909129;23436;100928;50.287926%;59964.832030;5644.844189;14.595833%;19.394167%;123706;0;7313;0.1%;0.1%;0.1%;0.1%;0.1%;0.1%;100.0%;0.00%;0.00%;0.00%;0.00%;0.00%;0.00%;0.01%;0.02%;0.05%;0.16%;6.04%;40.40%;52.68%;0.64%;0.01%;0.00%;0.01%;0.00%;0.00%;0.00%;0.00%;0.00%
A description of this job goes here.
</pre></div>
</div>
<p>The job description (if provided) follows on a second line.</p>
<p>To enable terse output, use the <a class="reference internal" href="#cmdoption--minimal"><code class="xref std std-option docutils literal"><span class="pre">--minimal</span></code></a> command line option. The
first value is the version of the terse output format. If the output has to be
changed for some reason, this number will be incremented by 1 to signify that
change.</p>
<p>Split up, the format is as follows:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre>terse version, fio version, jobname, groupid, error
</pre></div>
</div>
<p>READ status:</p>
<div class="highlight-python"><div class="highlight"><pre>Total IO (KiB), bandwidth (KiB/sec), IOPS, runtime (msec)
Submission latency: min, max, mean, stdev (usec)
Completion latency: min, max, mean, stdev (usec)
Completion latency percentiles: 20 fields (see below)
Total latency: min, max, mean, stdev (usec)
Bw (KiB/s): min, max, aggregate percentage of total, mean, stdev
</pre></div>
</div>
<p>WRITE status:</p>
<div class="highlight-python"><div class="highlight"><pre>Total IO (KiB), bandwidth (KiB/sec), IOPS, runtime (msec)
Submission latency: min, max, mean, stdev (usec)
Completion latency: min, max, mean, stdev(usec)
Completion latency percentiles: 20 fields (see below)
Total latency: min, max, mean, stdev (usec)
Bw (KiB/s): min, max, aggregate percentage of total, mean, stdev
</pre></div>
</div>
<p>CPU usage:</p>
<div class="highlight-python"><div class="highlight"><pre>user, system, context switches, major faults, minor faults
</pre></div>
</div>
<p>I/O depths:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;=1, 2, 4, 8, 16, 32, &gt;=64
</pre></div>
</div>
<p>I/O latencies microseconds:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;=2, 4, 10, 20, 50, 100, 250, 500, 750, 1000
</pre></div>
</div>
<p>I/O latencies milliseconds:</p>
<div class="highlight-python"><div class="highlight"><pre>&lt;=2, 4, 10, 20, 50, 100, 250, 500, 750, 1000, 2000, &gt;=2000
</pre></div>
</div>
<p>Disk utilization:</p>
<div class="highlight-python"><div class="highlight"><pre>Disk name, Read ios, write ios,
Read merges, write merges,
Read ticks, write ticks,
Time spent in queue, disk utilization percentage
</pre></div>
</div>
<p>Additional Info (dependent on continue_on_error, default off):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">total</span> <span class="c1"># errors, first error code</span>
</pre></div>
</div>
<p>Additional Info (dependent on description being set):</p>
<div class="highlight-python"><div class="highlight"><pre>Text description
</pre></div>
</div>
</div></blockquote>
<p>Completion latency percentiles can be a grouping of up to 20 sets, so for the
terse output fio writes all of them. Each field will look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">1.00</span><span class="o">%=</span><span class="mi">6112</span>
</pre></div>
</div>
<p>which is the Xth percentile, and the <cite>usec</cite> latency associated with it.</p>
<p>For disk utilization, all disks used by fio are shown. So for each disk there
will be a disk utilization section.</p>
</div>
<div class="section" id="trace-file-format">
<h2>Trace file format<a class="headerlink" href="#trace-file-format" title="Permalink to this headline">¶</a></h2>
<p>There are two trace file format that you can encounter. The older (v1) format is
unsupported since version 1.20-rc3 (March 2008). It will still be described
below in case that you get an old trace and want to understand it.</p>
<p>In any case the trace is a simple text file with a single action per line.</p>
<div class="section" id="trace-file-format-v1">
<h3>Trace file format v1<a class="headerlink" href="#trace-file-format-v1" title="Permalink to this headline">¶</a></h3>
<p>Each line represents a single I/O action in the following format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">rw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span>
</pre></div>
</div>
<p>where <cite>rw=0/1</cite> for read/write, and the offset and length entries being in bytes.</p>
<p>This format is not supported in fio versions =&gt; 1.20-rc3.</p>
</div>
<div class="section" id="trace-file-format-v2">
<h3>Trace file format v2<a class="headerlink" href="#trace-file-format-v2" title="Permalink to this headline">¶</a></h3>
<p>The second version of the trace file format was added in fio version 1.17.  It
allows to access more then one file per trace and has a bigger set of possible
file actions.</p>
<p>The first line of the trace file has to be:</p>
<div class="highlight-python"><div class="highlight"><pre>fio version 2 iolog
</pre></div>
</div>
<p>Following this can be lines in two different formats, which are described below.</p>
<p>The file management format:</p>
<div class="highlight-python"><div class="highlight"><pre>filename action
</pre></div>
</div>
<p>The filename is given as an absolute path. The action can be one of these:</p>
<dl class="docutils">
<dt><strong>add</strong></dt>
<dd>Add the given filename to the trace.</dd>
<dt><strong>open</strong></dt>
<dd>Open the file with the given filename. The filename has to have
been added with the <strong>add</strong> action before.</dd>
<dt><strong>close</strong></dt>
<dd>Close the file with the given filename. The file has to have been
opened before.</dd>
</dl>
<p>The file I/O action format:</p>
<div class="highlight-python"><div class="highlight"><pre>filename action offset length
</pre></div>
</div>
<p>The <cite>filename</cite> is given as an absolute path, and has to have been added and
opened before it can be used with this format. The <cite>offset</cite> and <cite>length</cite> are
given in bytes. The <cite>action</cite> can be one of these:</p>
<dl class="docutils">
<dt><strong>wait</strong></dt>
<dd>Wait for <cite>offset</cite> microseconds. Everything below 100 is discarded.
The time is relative to the previous <cite>wait</cite> statement.</dd>
<dt><strong>read</strong></dt>
<dd>Read <cite>length</cite> bytes beginning from <cite>offset</cite>.</dd>
<dt><strong>write</strong></dt>
<dd>Write <cite>length</cite> bytes beginning from <cite>offset</cite>.</dd>
<dt><strong>sync</strong></dt>
<dd><em class="manpage">fsync(2)</em> the file.</dd>
<dt><strong>datasync</strong></dt>
<dd><em class="manpage">fdatasync(2)</em> the file.</dd>
<dt><strong>trim</strong></dt>
<dd>Trim the given file from the given <cite>offset</cite> for <cite>length</cite> bytes.</dd>
</dl>
</div>
</div>
<div class="section" id="cpu-idleness-profiling">
<h2>CPU idleness profiling<a class="headerlink" href="#cpu-idleness-profiling" title="Permalink to this headline">¶</a></h2>
<p>In some cases, we want to understand CPU overhead in a test. For example, we
test patches for the specific goodness of whether they reduce CPU usage.
Fio implements a balloon approach to create a thread per CPU that runs at idle
priority, meaning that it only runs when nobody else needs the cpu.
By measuring the amount of work completed by the thread, idleness of each CPU
can be derived accordingly.</p>
<p>An unit work is defined as touching a full page of unsigned characters. Mean and
standard deviation of time to complete an unit work is reported in &#8220;unit work&#8221;
section. Options can be chosen to report detailed percpu idleness or overall
system idleness by aggregating percpu stats.</p>
</div>
<div class="section" id="verification-and-triggers">
<h2>Verification and triggers<a class="headerlink" href="#verification-and-triggers" title="Permalink to this headline">¶</a></h2>
<p>Fio is usually run in one of two ways, when data verification is done. The first
is a normal write job of some sort with verify enabled. When the write phase has
completed, fio switches to reads and verifies everything it wrote. The second
model is running just the write phase, and then later on running the same job
(but with reads instead of writes) to repeat the same I/O patterns and verify
the contents. Both of these methods depend on the write phase being completed,
as fio otherwise has no idea how much data was written.</p>
<p>With verification triggers, fio supports dumping the current write state to
local files. Then a subsequent read verify workload can load this state and know
exactly where to stop. This is useful for testing cases where power is cut to a
server in a managed fashion, for instance.</p>
<p>A verification trigger consists of two things:</p>
<ol class="arabic simple">
<li>Storing the write state of each job.</li>
<li>Executing a trigger command.</li>
</ol>
<p>The write state is relatively small, on the order of hundreds of bytes to single
kilobytes. It contains information on the number of completions done, the last X
completions, etc.</p>
<p>A trigger is invoked either through creation (&#8216;touch&#8217;) of a specified file in
the system, or through a timeout setting. If fio is run with
<a class="reference internal" href="#cmdoption--trigger-file"><code class="xref std std-option docutils literal"><span class="pre">--trigger-file</span></code></a> = <code class="file docutils literal"><span class="pre">/tmp/trigger-file</span></code>, then it will continually
check for the existence of <code class="file docutils literal"><span class="pre">/tmp/trigger-file</span></code>. When it sees this file, it
will fire off the trigger (thus saving state, and executing the trigger
command).</p>
<p>For client/server runs, there&#8217;s both a local and remote trigger. If fio is
running as a server backend, it will send the job states back to the client for
safe storage, then execute the remote trigger, if specified. If a local trigger
is specified, the server will still send back the write state, but the client
will then execute the trigger.</p>
<div class="section" id="verification-trigger-example">
<h3>Verification trigger example<a class="headerlink" href="#verification-trigger-example" title="Permalink to this headline">¶</a></h3>
<p>Lets say we want to run a powercut test on the remote machine &#8216;server&#8217;.  Our
write workload is in <code class="file docutils literal"><span class="pre">write-test.fio</span></code>. We want to cut power to &#8216;server&#8217; at
some point during the run, and we&#8217;ll run this test from the safety or our local
machine, &#8216;localbox&#8217;. On the server, we&#8217;ll start the fio backend normally:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">server</span><span class="c1"># fio --server</span>
</pre></div>
</div>
<p>and on the client, we&#8217;ll fire off the workload:</p>
<div class="highlight-python"><div class="highlight"><pre>localbox$ fio --client=server --trigger-file=/tmp/my-trigger --trigger-remote=&quot;bash -c \&quot;echo b &gt; /proc/sysrq-triger\&quot;&quot;
</pre></div>
</div>
<p>We set <code class="file docutils literal"><span class="pre">/tmp/my-trigger</span></code> as the trigger file, and we tell fio to execute:</p>
<div class="highlight-python"><div class="highlight"><pre>echo b &gt; /proc/sysrq-trigger
</pre></div>
</div>
<p>on the server once it has received the trigger and sent us the write state. This
will work, but it&#8217;s not <strong>really</strong> cutting power to the server, it&#8217;s merely
abruptly rebooting it. If we have a remote way of cutting power to the server
through IPMI or similar, we could do that through a local trigger command
instead. Lets assume we have a script that does IPMI reboot of a given hostname,
ipmi-reboot. On localbox, we could then have run fio with a local trigger
instead:</p>
<div class="highlight-python"><div class="highlight"><pre>localbox$ fio --client=server --trigger-file=/tmp/my-trigger --trigger=&quot;ipmi-reboot server&quot;
</pre></div>
</div>
<p>For this case, fio would wait for the server to send us the write state, then
execute <code class="docutils literal"><span class="pre">ipmi-reboot</span> <span class="pre">server</span></code> when that happened.</p>
</div>
<div class="section" id="loading-verify-state">
<h3>Loading verify state<a class="headerlink" href="#loading-verify-state" title="Permalink to this headline">¶</a></h3>
<p>To load store write state, read verification job file must contain the
<a class="reference internal" href="#cmdoption-arg-verify_state_load"><code class="xref std std-option docutils literal"><span class="pre">verify_state_load</span></code></a> option. If that is set, fio will load the previously
stored state. For a local fio run this is done by loading the files directly,
and on a client/server run, the server backend will ask the client to send the
files over and load them from there.</p>
</div>
</div>
<div class="section" id="log-file-formats">
<h2>Log File Formats<a class="headerlink" href="#log-file-formats" title="Permalink to this headline">¶</a></h2>
<p>Fio supports a variety of log file formats, for logging latencies, bandwidth,
and IOPS. The logs share a common format, which looks like this:</p>
<blockquote>
<div><em>time</em> (<cite>msec</cite>), <em>value</em>, <em>data direction</em>, <em>offset</em></div></blockquote>
<p>Time for the log entry is always in milliseconds. The <em>value</em> logged depends
on the type of log, it will be one of the following:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>Latency log</strong></dt>
<dd>Value is latency in usecs</dd>
<dt><strong>Bandwidth log</strong></dt>
<dd>Value is in KiB/sec</dd>
<dt><strong>IOPS log</strong></dt>
<dd>Value is IOPS</dd>
</dl>
</div></blockquote>
<p><em>Data direction</em> is one of the following:</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>0</strong></dt>
<dd>I/O is a READ</dd>
<dt><strong>1</strong></dt>
<dd>I/O is a WRITE</dd>
<dt><strong>2</strong></dt>
<dd>I/O is a TRIM</dd>
</dl>
</div></blockquote>
<p>The <em>offset</em> is the offset, in bytes, from the start of the file, for that
particular I/O. The logging of the offset can be toggled with
<a class="reference internal" href="#cmdoption-arg-log_offset"><code class="xref std std-option docutils literal"><span class="pre">log_offset</span></code></a>.</p>
<p>If windowed logging is enabled through <a class="reference internal" href="#cmdoption-arg-log_avg_msec"><code class="xref std std-option docutils literal"><span class="pre">log_avg_msec</span></code></a> then fio doesn&#8217;t
log individual I/Os. Instead of logs the average values over the specified period
of time. Since &#8216;data direction&#8217; and &#8216;offset&#8217; are per-I/O values, they aren&#8217;t
applicable if windowed logging is enabled. If windowed logging is enabled and
<a class="reference internal" href="#cmdoption-arg-log_max_value"><code class="xref std std-option docutils literal"><span class="pre">log_max_value</span></code></a> is set, then fio logs maximum values in that window
instead of averages.</p>
</div>
<div class="section" id="client-server">
<h2>Client/server<a class="headerlink" href="#client-server" title="Permalink to this headline">¶</a></h2>
<p>Normally fio is invoked as a stand-alone application on the machine where the
I/O workload should be generated. However, the frontend and backend of fio can
be run separately. Ie the fio server can generate an I/O workload on the &#8220;Device
Under Test&#8221; while being controlled from another machine.</p>
<p>Start the server on the machine which has access to the storage DUT:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fio</span> <span class="o">--</span><span class="n">server</span><span class="o">=</span><span class="n">args</span>
</pre></div>
</div>
<p>where args defines what fio listens to. The arguments are of the form
<code class="docutils literal"><span class="pre">type,hostname</span></code> or <code class="docutils literal"><span class="pre">IP,port</span></code>. <em>type</em> is either <code class="docutils literal"><span class="pre">ip</span></code> (or ip4) for TCP/IP
v4, <code class="docutils literal"><span class="pre">ip6</span></code> for TCP/IP v6, or <code class="docutils literal"><span class="pre">sock</span></code> for a local unix domain socket.
<em>hostname</em> is either a hostname or IP address, and <em>port</em> is the port to listen
to (only valid for TCP/IP, not a local socket). Some examples:</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal"><span class="pre">fio</span> <span class="pre">--server</span></code></p>
<p>Start a fio server, listening on all interfaces on the default port (8765).</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">fio</span> <span class="pre">--server=ip:hostname,4444</span></code></p>
<p>Start a fio server, listening on IP belonging to hostname and on port 4444.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">fio</span> <span class="pre">--server=ip6:::1,4444</span></code></p>
<p>Start a fio server, listening on IPv6 localhost ::1 and on port 4444.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">fio</span> <span class="pre">--server=,4444</span></code></p>
<p>Start a fio server, listening on all interfaces on port 4444.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">fio</span> <span class="pre">--server=1.2.3.4</span></code></p>
<p>Start a fio server, listening on IP 1.2.3.4 on the default port.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">fio</span> <span class="pre">--server=sock:/tmp/fio.sock</span></code></p>
<p>Start a fio server, listening on the local socket /tmp/fio.sock.</p>
</li>
</ol>
<p>Once a server is running, a &#8220;client&#8221; can connect to the fio server with:</p>
<div class="highlight-python"><div class="highlight"><pre>fio &lt;local-args&gt; --client=&lt;server&gt; &lt;remote-args&gt; &lt;job file(s)&gt;
</pre></div>
</div>
<p>where <cite>local-args</cite> are arguments for the client where it is running, <cite>server</cite>
is the connect string, and <cite>remote-args</cite> and <cite>job file(s)</cite> are sent to the
server. The <cite>server</cite> string follows the same format as it does on the server
side, to allow IP/hostname/socket and port strings.</p>
<p>Fio can connect to multiple servers this way:</p>
<div class="highlight-python"><div class="highlight"><pre>fio --client=&lt;server1&gt; &lt;job file(s)&gt; --client=&lt;server2&gt; &lt;job file(s)&gt;
</pre></div>
</div>
<p>If the job file is located on the fio server, then you can tell the server to
load a local file as well. This is done by using <a class="reference internal" href="#cmdoption--remote-config"><code class="xref std std-option docutils literal"><span class="pre">--remote-config</span></code></a></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fio</span> <span class="o">--</span><span class="n">client</span><span class="o">=</span><span class="n">server</span> <span class="o">--</span><span class="n">remote</span><span class="o">-</span><span class="n">config</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="nb">file</span><span class="o">.</span><span class="n">fio</span>
</pre></div>
</div>
<p>Then fio will open this local (to the server) job file instead of being passed
one from the client.</p>
<p>If you have many servers (example: 100 VMs/containers), you can input a pathname
of a file containing host IPs/names as the parameter value for the
<a class="reference internal" href="#cmdoption--client"><code class="xref std std-option docutils literal"><span class="pre">--client</span></code></a> option.  For example, here is an example <code class="file docutils literal"><span class="pre">host.list</span></code>
file containing 2 hostnames:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">host1</span><span class="o">.</span><span class="n">your</span><span class="o">.</span><span class="n">dns</span><span class="o">.</span><span class="n">domain</span>
<span class="n">host2</span><span class="o">.</span><span class="n">your</span><span class="o">.</span><span class="n">dns</span><span class="o">.</span><span class="n">domain</span>
</pre></div>
</div>
<p>The fio command would then be:</p>
<div class="highlight-python"><div class="highlight"><pre>fio --client=host.list &lt;job file(s)&gt;
</pre></div>
</div>
<p>In this mode, you cannot input server-specific parameters or job files &#8211; all
servers receive the same job file.</p>
<p>In order to let <code class="docutils literal"><span class="pre">fio</span> <span class="pre">--client</span></code> runs use a shared filesystem from multiple
hosts, <code class="docutils literal"><span class="pre">fio</span> <span class="pre">--client</span></code> now prepends the IP address of the server to the
filename.  For example, if fio is using directory <code class="file docutils literal"><span class="pre">/mnt/nfs/fio</span></code> and is
writing filename <code class="file docutils literal"><span class="pre">fileio.tmp</span></code>, with a <a class="reference internal" href="#cmdoption--client"><code class="xref std std-option docutils literal"><span class="pre">--client</span></code></a> <cite>hostfile</cite>
containing two hostnames <code class="docutils literal"><span class="pre">h1</span></code> and <code class="docutils literal"><span class="pre">h2</span></code> with IP addresses 192.168.10.120 and
192.168.10.121, then fio will create two files:</p>
<div class="highlight-python"><div class="highlight"><pre>/mnt/nfs/fio/192.168.10.120.fileio.tmp
/mnt/nfs/fio/192.168.10.121.fileio.tmp
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Fio Manpage</a><ul>
<li><a class="reference internal" href="#overview-and-history">Overview and history</a></li>
<li><a class="reference internal" href="#source">Source</a></li>
<li><a class="reference internal" href="#mailing-list">Mailing list</a></li>
<li><a class="reference internal" href="#author">Author</a></li>
<li><a class="reference internal" href="#binary-packages">Binary packages</a></li>
<li><a class="reference internal" href="#building">Building</a><ul>
<li><a class="reference internal" href="#windows">Windows</a></li>
<li><a class="reference internal" href="#documentation">Documentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#platforms">Platforms</a></li>
<li><a class="reference internal" href="#running-fio">Running fio</a></li>
<li><a class="reference internal" href="#how-fio-works">How fio works</a></li>
<li><a class="reference internal" href="#command-line-options">Command line options</a></li>
<li><a class="reference internal" href="#job-file-format">Job file format</a><ul>
<li><a class="reference internal" href="#environment-variables">Environment variables</a></li>
<li><a class="reference internal" href="#reserved-keywords">Reserved keywords</a></li>
</ul>
</li>
<li><a class="reference internal" href="#job-file-parameters">Job file parameters</a><ul>
<li><a class="reference internal" href="#parameter-types">Parameter types</a></li>
<li><a class="reference internal" href="#units">Units</a></li>
<li><a class="reference internal" href="#job-description">Job description</a></li>
<li><a class="reference internal" href="#time-related-parameters">Time related parameters</a></li>
<li><a class="reference internal" href="#target-file-device">Target file/device</a></li>
<li><a class="reference internal" href="#i-o-type">I/O type</a></li>
<li><a class="reference internal" href="#block-size">Block size</a></li>
<li><a class="reference internal" href="#buffers-and-memory">Buffers and memory</a></li>
<li><a class="reference internal" href="#i-o-size">I/O size</a></li>
<li><a class="reference internal" href="#i-o-engine">I/O engine</a></li>
<li><a class="reference internal" href="#i-o-engine-specific-parameters">I/O engine specific parameters</a></li>
<li><a class="reference internal" href="#i-o-depth">I/O depth</a></li>
<li><a class="reference internal" href="#i-o-rate">I/O rate</a></li>
<li><a class="reference internal" href="#i-o-latency">I/O latency</a></li>
<li><a class="reference internal" href="#i-o-replay">I/O replay</a></li>
<li><a class="reference internal" href="#threads-processes-and-job-synchronization">Threads, processes and job synchronization</a></li>
<li><a class="reference internal" href="#verification">Verification</a></li>
<li><a class="reference internal" href="#steady-state">Steady state</a></li>
<li><a class="reference internal" href="#measurements-and-reporting">Measurements and reporting</a></li>
<li><a class="reference internal" href="#error-handling">Error handling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-predefined-workloads">Running predefined workloads</a><ul>
<li><a class="reference internal" href="#act-profile-options">Act profile options</a></li>
<li><a class="reference internal" href="#tiobench-profile-options">Tiobench profile options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interpreting-the-output">Interpreting the output</a></li>
<li><a class="reference internal" href="#terse-output">Terse output</a></li>
<li><a class="reference internal" href="#trace-file-format">Trace file format</a><ul>
<li><a class="reference internal" href="#trace-file-format-v1">Trace file format v1</a></li>
<li><a class="reference internal" href="#trace-file-format-v2">Trace file format v2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cpu-idleness-profiling">CPU idleness profiling</a></li>
<li><a class="reference internal" href="#verification-and-triggers">Verification and triggers</a><ul>
<li><a class="reference internal" href="#verification-trigger-example">Verification trigger example</a></li>
<li><a class="reference internal" href="#loading-verify-state">Loading verify state</a></li>
</ul>
</li>
<li><a class="reference internal" href="#log-file-formats">Log File Formats</a></li>
<li><a class="reference internal" href="#client-server">Client/server</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/fio_man.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jens Axboe <axboe@kernel.dk>.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/fio_man.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>